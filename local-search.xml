<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>重新认识NIO</title>
    <link href="/2021/04/28/yq/ywflt3/"/>
    <url>/2021/04/28/yq/ywflt3/</url>
    
    <content type="html"><![CDATA[<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>non-blocking io</p><h2 id="1-三大组件"><a href="#1-三大组件" class="headerlink" title="1. 三大组件"></a>1. 三大组件</h2><h3 id="1-1-Channel-amp-Buffer"><a href="#1-1-Channel-amp-Buffer" class="headerlink" title="1.1 Channel &amp; Buffer"></a>1.1 Channel &amp; Buffer</h3><p>channel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 中将数据读入 buffer，也可以将 buffer 的数据写入到 channel 中，而之前的 stream 要么是输入要么是输出，stream 是单向通道，channel 相比较于 stream 更为底层。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12942619/1619622568255-fc43f3fd-a36d-4c42-ae62-a846cac4a62c.png#align=left&display=inline&height=69&margin=%5Bobject%20Object%5D&name=image.png&originHeight=138&originWidth=441&size=8533&status=done&style=none&width=221" alt="image.png"></p><p>常见的 Channel 有</p><ul><li>FileChannel</li><li>DatagramChannel (udp)</li><li>SocketChannel (tcp)</li><li>ServerSocketChannel (tcp)</li></ul><p>buffer 用来缓冲读写数据，常见的 buffer 有</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><h3 id="1-2-Selector"><a href="#1-2-Selector" class="headerlink" title="1.2 Selector"></a>1.2 Selector</h3><p>Selector 的作用是什么？<br>选择器提供选择执行已经就绪的任务的能力。从底层来看，Selector 提供了询问通道是否已经准备好执行每个 I/O 操作的能力。Selector 允许单线程处理多个 Channel。仅用单个线程来处理多个 Channels 的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道，这样会大量的减少线程之间上下文切换的开销。</p><p>在使用 Selector 之前，处理 socket 连接还有以下两种方法</p><h4 id="1-2-1-使用多线程技术"><a href="#1-2-1-使用多线程技术" class="headerlink" title="1.2.1 使用多线程技术"></a>1.2.1 使用多线程技术</h4><p>为每个连接分别开辟一个线程，分别去处理对应的 socket 连接<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12942619/1619687916426-a16ed3da-cb06-4758-aaa4-c0deef4b8cc7.png#align=left&display=inline&height=249&margin=%5Bobject%20Object%5D&originHeight=249&originWidth=584&size=0&status=done&style=none&width=584"><br>这种方法存在以下几个问题</p><ul><li>内存占用高<ul><li>每个线程都需要占用一定的内存，当连接较多时，会开辟大量线程，导致占用大量内存</li></ul></li><li>线程上下文切换成本高</li><li>只适合连接数少的场景<ul><li>连接数过多，会导致创建很多线程，从而出现问题</li></ul></li></ul><h4 id="1-2-2-使用线程池技术"><a href="#1-2-2-使用线程池技术" class="headerlink" title="1.2.2 使用线程池技术"></a>1.2.2 使用线程池技术</h4><p>使用线程池，让线程池中的线程去处理连接<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12942619/1619687917465-b3399005-a475-4f1a-b694-ebdef3fefe89.png#align=left&display=inline&height=246&margin=%5Bobject%20Object%5D&originHeight=246&originWidth=771&size=0&status=done&style=none&width=771"><br>这种方法存在以下几个问题</p><ul><li>阻塞模式下，线程仅能处理一个连接<ul><li>线程池中的线程获取任务（task）后，<strong>只有当其执行完任务之后（断开连接后），才会去获取并执行下一个任务</strong></li><li>若 socket 连接一直未断开，则其对应的线程无法处理其他 socket 连接</li></ul></li><li>仅适合<strong>短连接</strong>场景<ul><li>短连接即建立连接发送请求并响应后就立即断开，使得线程池中的线程可以快速处理其他连接</li></ul></li></ul><h4 id="1-2-3-使用选择器"><a href="#1-2-3-使用选择器" class="headerlink" title="1.2.3 使用选择器"></a>1.2.3 使用选择器</h4><p><strong>selector 的作用就是配合一个线程来管理多个 channel（fileChannel 因为是阻塞式的，所以无法使用 selector）</strong>，获取这些 channel 上发生的<strong>事件</strong>，这些 channel 工作在<strong>非阻塞模式</strong>下，当一个 channel 中没有执行任务时，可以去执行其他 channel 中的任务。<strong>适合连接数多，但流量较少的场景</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12942619/1619687916440-d1d112ee-d5c7-4b8d-a7fa-f9142011f519.png#align=left&display=inline&height=356&margin=%5Bobject%20Object%5D&originHeight=356&originWidth=592&size=0&status=done&style=none&width=592"><br>若事件未就绪，调用 selector 的 select() 方法会阻塞线程，直到 channel 发生了就绪事件。这些事件就绪后，select 方法就会返回这些事件交给 thread 来处理。</p><h4 id="1-2-4-可选择通道-SelectableChannel"><a href="#1-2-4-可选择通道-SelectableChannel" class="headerlink" title="1.2.4 可选择通道(SelectableChannel)"></a>1.2.4 可选择通道(SelectableChannel)</h4><p>并不是所有的 Channel，都是可以被 Selector 复用的。比方说，FileChannel 就不能被选择器复用。为什么呢？<br>判断一个 Channel 能被 Selector 复用，有一个前提：判断他是否继承了一个抽象类 SelectableChannel。如果继承了 SelectableChannel，则可以被复用，否则不能。<br>SelectableChannel 类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。所有 socket 通道，都继承了 SelectableChannel 类都是可选择的，包括从管道(Pipe)对象的中获得的通道。而 FileChannel 类，没有继承 SelectableChannel，因此是不是可选通道。<br>通道和选择器注册之后，他们是绑定的关系吗？<br>答案是不是。不是一对一的关系。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。<br>通道和选择器之间的关系，使用注册的方式完成。SelectableChannel 可以被注册到 Selector 对象上，在注册的时候，需要指定通道的哪些操作，是 Selector 感兴趣的。</p><h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2. ByteBuffer"></a>2. ByteBuffer</h2><p>缓冲区(Buffer)就是在内存中预留指定大小的存储空间用来对输入/输出(I/O)的数据作临时存储，这部分预留的内存空间就叫做缓冲区：<br>使用缓冲区有这么两个好处：</p><ul><li>减少实际的物理读写次数</li><li>缓冲区在创建时就被分配内存，这块内存区域一直被重用，可以减少动态分配和回收内存的次数</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12942619/1619710574469-de80a221-347a-4846-a5ea-743c7d30fb30.jpeg">时序图~<br><img src="https://cdn.nlark.com/yuque/__mermaid_v3/08e6f45ca07eea45b678d0f6dd1308b5.svg#lake_card_v2=eyJjb2RlIjoiZ3JhcGggTFJcbiAgICBBW1NxdWFyZSBSZWN0XSAtLSBMaW5rIHRleHQgLS0-IEIoKENpcmNsZSkpXG4gICAgQSAtLT4gQyhSb3VuZCBSZWN0KVxuICAgIEIgLS0-IER7UmhvbWJ1c31cbiAgICBDIC0tPiBEXG4gICAgRCAtLT4gRSIsInR5cGUiOiJtZXJtYWlkIiwibWFyZ2luIjp0cnVlLCJpZCI6Im56NHJEIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fbWVybWFpZF92My8wOGU2ZjQ1Y2EwN2VlYTQ1YjY3OGQwZjZkZDEzMDhiNS5zdmciLCJjYXJkIjoiZGlhZ3JhbSJ9"></p>]]></content>
    
    
    <categories>
      
      <category>netty</category>
      
      <category>nio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>netty</tag>
      
      <tag>nio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重置Navicat试用时间</title>
    <link href="/2021/04/28/yq/rauyu5/"/>
    <url>/2021/04/28/yq/rauyu5/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/12942619/1619576990607-23b58acb-5b95-483a-83b2-161a47a82ef6.png#align=left&display=inline&height=156&margin=%5Bobject%20Object%5D&name=image.png&originHeight=622&originWidth=751&size=53479&status=done&style=none&width=188" alt="image.png"></h2><h1 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h1><p>Navicat Premium 15 (Windows)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><br><span class="hljs-built_in">echo</span> Delete HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPremium\Registration15XCS<br><span class="hljs-built_in">echo</span> waiting......<br>reg delete <span class="hljs-string">&quot;HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPremium\Registration15XCS&quot;</span> /va /f<br><span class="hljs-built_in">echo</span>.<br><br><span class="hljs-built_in">echo</span> Delete Info folder under HKEY_CURRENT_USER\Software\Classes\CLSID<br><span class="hljs-built_in">echo</span> waiting......<br><br><span class="hljs-keyword">for</span> /f %%i <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;&quot;REG QUERY &quot;HKEY_CURRENT_USER\Software\Classes\CLSID&quot; /s | findstr /E Info&quot;&#x27;</span>) <span class="hljs-keyword">do</span> (<br>    reg delete %%i /va /f<br>)<br><br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">echo</span> Finish<br><br>pause<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>navicat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>navicat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bios setting for mac</title>
    <link href="/2021/04/12/yq/oi71k3/"/>
    <url>/2021/04/12/yq/oi71k3/</url>
    
    <content type="html"><![CDATA[<h2 id="AMD-BIOS-Settings"><a href="#AMD-BIOS-Settings" class="headerlink" title="#AMD BIOS Settings"></a><a href="https://dortania.github.io/OpenCore-Install-Guide/AMD/zen.html#amd-bios-settings">#</a>AMD BIOS Settings</h2><p>Note: Most of these options may not be present in your firmware, we recommend matching up as closely as possible but don’t be too concerned if many of these options are not available in your BIOS<br><a href="https://dortania.github.io/OpenCore-Install-Guide/AMD/zen.html#disable">#</a>Disable<br>Fast Boot<br>Secure Boot<br>Serial/COM Port<br>Parallel Port<br>Compatibility Support Module (CSM)(<strong>Must be off, GPU errors like <code>gIO</code> are common when this option in enabled</strong>)<br><strong>Special note for 3990X users</strong>: macOS currently does not support more than 64 threads in the kernel, and so will kernel panic if it sees more. The 3990X CPU has 128 threads total and so requires half of that disabled. We recommend disabling hyper threading in the BIOS for these situations.<br><a href="https://dortania.github.io/OpenCore-Install-Guide/AMD/zen.html#enable">#</a>Enable<br>Above 4G decoding(<strong>This must be on, if you can’t find the option then add <code>npci=0x2000</code> to boot-args. Do not have both this option and npci enabled at the same time.</strong>)</p><ul><li>If you are on a Gigabyte/Aorus or an AsRock motherboard, enabling this option may break certain drivers(ie. Ethernet) and/or boot failures on other OSes, if it does happen then disable this option and opt for npci instead</li><li>2020+ BIOS Notes: When enabling Above4G, Resizable BAR Support may become an available on some X570 and newer motherboards. Please ensure this is <strong>Disabled</strong> instead of set to Auto.</li></ul><p>EHCI/XHCI Hand-off<br>OS type: Windows 8.1/10 UEFI Mode<br>SATA Mode: AHCI</p>]]></content>
    
    
    <categories>
      
      <category>bios</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring-boot 自动装配</title>
    <link href="/2021/03/30/yq/skdzb0/"/>
    <url>/2021/03/30/yq/skdzb0/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ConfigurableApplicationContext context = SpringApplication.run(DemoApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 SpringApplication.run 可以进入方法得知 spring 底层自动扫描所有在<strong>META-INF/spring.factories</strong>中默认配置好的自动装配类，然后根据条件按需加载组件（bean）到 spring 容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;<br><br>   <span class="hljs-keyword">try</span> &#123;<br>      Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-keyword">null</span> ?<br>            classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :<br>            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cc.voox.demo;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.context.ConfigurableApplicationContext;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplication</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>@SpringBootApplication 是由多个注解组合而成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>@SpringBootConfiguration 和@Configuration 功能一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>@<strong>SpringBootConfiguration</strong> is a class-level annotation that is part of the Spring Boot framework. It indicates that a class provides application configuration. Spring Boot favors Java-based configuration. As a result, the @<strong>SpringBootConfiguration</strong> annotation is the primary source for configuration in applications.</p></blockquote><p><em>@ComponentScan 包扫描器</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>自动导入<strong>AutoConfigurationImportSelector</strong> 组件后，通过<strong>selectImports</strong>方法封装所有满足的类成<strong>AutoConfigurationEntry</strong>进行导入<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12942619/1617161430606-5e989111-2002-47c2-b357-e6bf788f0b7a.png#align=left&display=inline&height=676&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1351&originWidth=1961&size=355828&status=done&style=none&width=980.5" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><br>AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);<br><span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br><span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>&#125;<br>AnnotationAttributes attributes = getAttributes(annotationMetadata);<br>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);<br>configurations = removeDuplicates(configurations);<br>Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);<br>checkExcludedClasses(configurations, exclusions);<br>configurations.removeAll(exclusions);<br>configurations = getConfigurationClassFilter().filter(configurations);<br>fireAutoConfigurationImportEvents(configurations, exclusions);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationEntry(configurations, exclusions);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用<strong>PackageImports</strong>类批量注册组件到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Import(AutoConfigurationPackages.Registrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">DeterminableImports</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>register(registry, <span class="hljs-keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty模型</title>
    <link href="/2020/10/29/Netty%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/10/29/Netty%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>提及Netty模型，不得不从Reactor 模式说起， Reactor模式是基于事件驱动，特别适合处理海量的 I/O 事件。</p><p>Reactor 模式下，又细分为：</p><ul><li>单线程模型</li><li>多线程模型</li><li>主从多线程模型</li></ul><h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程的职责如下：</p><ul><li><p>作为 NIO 服务端，接收客户端的 TCP 连接；</p></li><li><p>作为 NIO 客户端，向服务端发起 TCP 连接；</p></li><li><p>读取通信对端的请求或者应答消息；</p></li><li><p>向通信对端发送消息请求或者应答消息。</p></li></ul><p>Reactor 单线程模型示意图如下所示：</p><img src="/2020/10/29/Netty%E6%A8%A1%E5%9E%8B/image-1603982976.png" class="" title="some description"><p>由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独立处理所有 IO 相关的操作。从架构层面看，一个 NIO 线程确实可以完成其承担的职责。例如，通过 Acceptor 类接收客户端的 TCP 连接请求消息，链路建立成功之后，通过 Dispatch 将对应的 ByteBuffer 派发到指定的 Handler 上进行消息解码。用户线程可以通过消息编码通过 NIO 线程将消息发送给客户端。</p><p>对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发的应用场景却不合适，主要原因如下：</p><ul><li><p>一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，即便 NIO 线程的 CPU 负荷达到 100%，也无法满足海量消息的编码、解码、读取和发送；</p></li><li><p>当 NIO 线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了 NIO 线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；</p></li><li><p>可靠性问题：一旦 NIO 线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</p></li></ul><p>为了解决这些问题，演进出了 Reactor 多线程模型，下面我们一起学习下 Reactor 多线程模型。</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作，它的原理图如下：</p><img src="/2020/10/29/Netty%E6%A8%A1%E5%9E%8B/image-1603982991.png" class="" title="some description"><p>Reactor 多线程模型的特点：</p><ul><li><p>有专门一个 NIO 线程 -Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求；</p></li><li><p>网络 IO 操作 - 读、写等由一个 NIO 线程池负责，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N 个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送；</p></li><li><p>1 个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，防止发生并发操作问题。</p></li></ul><p>在绝大多数场景下，Reactor 多线程模型都可以满足性能需求；但是，在极个别特殊场景中，一个 NIO 线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个 Acceptor 线程可能会存在性能不足问题，为了解决性能问题，产生了第三种 Reactor 线程模型 - 主从 Reactor 多线程模型。</p><h3 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h3><p>主从 Reactor 线程模型的特点是：服务端用于接收客户端连接的不再是个 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池。Acceptor 接收到客户端 TCP 连接请求处理完成后（可能包含接入认证等），将新创建的 SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责 SocketChannel 的读写和编解码工作。Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作。</p><p>它的线程模型如下图所示：</p><img src="/2020/10/29/Netty%E6%A8%A1%E5%9E%8B/image-1603983106.png" class="" title="some description"><p>利用主从 NIO 线程模型，可以解决 1 个服务端监听线程无法有效处理所有客户端连接的性能不足问题。</p><p>它的工作流程总结如下：</p><ul><li>从主线程池中随机选择一个 Reactor 线程作为 Acceptor 线程，用于绑定监听端口，接收客户端连接；</li><li>Acceptor 线程接收客户端连接请求之后创建新的 SocketChannel，将其注册到主线程池的其它 Reactor 线程上，由其负责接入认证、IP 黑白名单过滤、握手等操作；</li><li>步骤 2 完成之后，业务层的链路正式建立，将 SocketChannel 从主线程池的 Reactor 线程的多路复用器上摘除，重新注册到 Sub 线程池的线程上，用于处理 I/O 的读写操作。</li></ul><h3 id="Netty-线程模型"><a href="#Netty-线程模型" class="headerlink" title="Netty 线程模型"></a>Netty 线程模型</h3><h4 id="服务端线程模型"><a href="#服务端线程模型" class="headerlink" title="服务端线程模型"></a>服务端线程模型</h4><p>一种比较流行的做法是服务端监听线程和 IO 线程分离，类似于 Reactor 的多线程模型，它的工作原理图如下：</p><img src="/2020/10/29/Netty%E6%A8%A1%E5%9E%8B/image-1603983165.png" class="" title="netty thread mode"><p>下面我们结合 Netty 的源码，对服务端创建线程工作流程进行介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    NioEventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>    NioEventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>    <span class="hljs-keyword">try</span> &#123;<br>        ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>        serverBootstrap.group(bossGroup, workerGroup)<br>                .channel(NioServerSocketChannel.class)<br>                .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)<br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> ServerHandler());<br>                    &#125;<br>                &#125;);<br>        System.out.println(<span class="hljs-string">&quot;server is up!&quot;</span>);<br>        ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">6668</span>).sync();<br>        channelFuture.channel().closeFuture().sync();<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        bossGroup.shutdownGracefully();<br>        workerGroup.shutdownGracefully();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况下，服务端的创建是在用户进程启动的时候进行，因此一般由 Main 函数或者启动类负责创建，服务端的创建由业务线程负责完成。在创建服务端的时候实例化了 2 个 EventLoopGroup，1 个 EventLoopGroup 实际就是一个 EventLoop 线程组，负责管理 EventLoop 的申请和释放。</p><p>EventLoopGroup 管理的线程数可以通过构造函数设置，如果没有设置，默认取 <code>-Dio.netty.eventLoopThreads</code>，如果该系统参数也没有指定，则为可用的 CPU 内核数 × 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultithreadEventLoopGroup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MultithreadEventExecutorGroup</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EventLoopGroup</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_EVENT_LOOP_THREADS;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<br>                <span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));<br><br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;</span>, DEFAULT_EVENT_LOOP_THREADS);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>bossGroup 线程组实际就是 Acceptor 线程池，负责处理客户端的 TCP 连接请求，如果系统只有一个服务端端口需要监听，则建议 bossGroup 线程组线程数设置为 1。</p><p>workerGroup 是真正负责 I/O 读写操作的线程组，通过 ServerBootstrap 的 group 方法进行设置，用于后续的 Channel 绑定。</p><hr><p>抽象出NioEventLoop来表示一个不断循环执行处理任务的线程，每个NioEventLoop有一个selector，用于监听绑定在其上的socket链路。</p><h4 id="1、串行化设计避免线程竞争"><a href="#1、串行化设计避免线程竞争" class="headerlink" title="1、串行化设计避免线程竞争"></a>1、串行化设计避免线程竞争</h4><p>netty采用串行化设计理念，从消息的读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送，始终由IO线程NioEventLoop负责。整个流程不会进行线程上下文切换，数据无并发修改风险。</p><p>一个NioEventLoop聚合一个多路复用器selector，因此可以处理多个客户端连接。</p><p>netty只负责提供和管理“IO线程”，其他的业务线程模型由用户自己集成。</p><p>时间可控的简单业务建议直接在“IO线程”上处理，复杂和时间不可控的业务建议投递到后端业务线程池中处理。</p><h4 id="2、定时任务与时间轮"><a href="#2、定时任务与时间轮" class="headerlink" title="2、定时任务与时间轮"></a>2、定时任务与时间轮</h4><p>NioEventLoop中的Thread线程按照时间轮中的步骤不断循环执行：</p><p>a)在时间片Tirck内执行selector.select()轮询监听IO事件；</p><p>b)处理监听到的就绪IO事件；</p><p>c)执行任务队列taskQueue/delayTaskQueue中的非IO任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    select(wakenUp.getAndSet(<span class="hljs-keyword">false</span>));<br><br>                    <span class="hljs-comment">// &#x27;wakenUp.compareAndSet(false, true)&#x27; is always evaluated</span><br>                    <span class="hljs-comment">// before calling &#x27;selector.wakeup()&#x27; to reduce the wake-up</span><br>                    <span class="hljs-comment">// overhead. (Selector.wakeup() is an expensive operation.)</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// However, there is a race condition in this approach.</span><br>                    <span class="hljs-comment">// The race condition is triggered when &#x27;wakenUp&#x27; is set to</span><br>                    <span class="hljs-comment">// true too early.</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// &#x27;wakenUp&#x27; is set to true too early if:</span><br>                    <span class="hljs-comment">// 1) Selector is waken up between &#x27;wakenUp.set(false)&#x27; and</span><br>                    <span class="hljs-comment">//    &#x27;selector.select(...)&#x27;. (BAD)</span><br>                    <span class="hljs-comment">// 2) Selector is waken up between &#x27;selector.select(...)&#x27; and</span><br>                    <span class="hljs-comment">//    &#x27;if (wakenUp.get()) &#123; ... &#125;&#x27;. (OK)</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// In the first case, &#x27;wakenUp&#x27; is set to true and the</span><br>                    <span class="hljs-comment">// following &#x27;selector.select(...)&#x27; will wake up immediately.</span><br>                    <span class="hljs-comment">// Until &#x27;wakenUp&#x27; is set to false again in the next round,</span><br>                    <span class="hljs-comment">// &#x27;wakenUp.compareAndSet(false, true)&#x27; will fail, and therefore</span><br>                    <span class="hljs-comment">// any attempt to wake up the Selector will fail, too, causing</span><br>                    <span class="hljs-comment">// the following &#x27;selector.select(...)&#x27; call to block</span><br>                    <span class="hljs-comment">// unnecessarily.</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// To fix this problem, we wake up the selector again if wakenUp</span><br>                    <span class="hljs-comment">// is true immediately after selector.select(...).</span><br>                    <span class="hljs-comment">// It is inefficient in that it wakes up the selector for both</span><br>                    <span class="hljs-comment">// the first case (BAD - wake-up required) and the second case</span><br>                    <span class="hljs-comment">// (OK - no wake-up required).</span><br><br>                    <span class="hljs-keyword">if</span> (wakenUp.get()) &#123;<br>                        selector.wakeup();<br>                    &#125;<br>                    <span class="hljs-comment">// fall through</span><br>                <span class="hljs-keyword">default</span>:<br>            &#125;<br><br>            cancelledKeys = <span class="hljs-number">0</span>;<br>            needsToSelectAgain = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;<br>            <span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// Ensure we always run tasks.</span><br>                    runAllTasks();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    processSelectedKeys();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// Ensure we always run tasks.</span><br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;<br>                    runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>        <span class="hljs-comment">// Always handle shutdown even if the loop processing threw an exception.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (isShuttingDown()) &#123;<br>                closeAll();<br>                <span class="hljs-keyword">if</span> (confirmShutdown()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            handleLoopException(t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="NioEventLoop与NioChannel类关系"><a href="#NioEventLoop与NioChannel类关系" class="headerlink" title="NioEventLoop与NioChannel类关系"></a>NioEventLoop与NioChannel类关系</h3><img src="/2020/10/29/Netty%E6%A8%A1%E5%9E%8B/image-1603983917.png" class="" title="some description"><p>一个NioEventLoopGroup下包含多个NioEventLoop</p><p>每个NioEventLoop中包含有一个Selector，一个taskQueue，一个delayedTaskQueue</p><p>每个NioEventLoop的Selector上可以注册监听多个AbstractNioChannel</p><p>每个AbstractNioChannel只会绑定在唯一的NioEventLoop上</p><p>每个AbstractNioChannel都绑定有一个自己的DefaultChannelPipeline</p>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
      <tag>nio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux五种IO模型</title>
    <link href="/2020/10/27/linux%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/10/27/linux%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>Linux下主要的IO主要分为：阻塞IO(Blocking IO)，非阻塞IO(Non-blocking IO)，同步IO(Sync IO)和异步IO(Async IO)。<br>同步：调用端会一直等待服务端响应，直到返回结果。<br>异步：调用端发起调用之后不会立刻返回，不会等待服务端响应。服务端通过通知机制或者回调函数来通知客户端。<br>阻塞：服务端返回结果之前，客户端线程会被挂起，此时线程不可被CPU调度，线程暂停运行。<br>非阻塞：在服务端返回前，函数不会阻塞调用端线程，而会立刻返回。<br>同步异步的区别在于：服务端在拷贝数据时是否阻塞调用端线程；阻塞和非阻塞的区别在于：调用端线程在调用function后是否立刻返回。要理解这些I/O，需要先理解一些基本的概念。</p><h2 id="用户态和核心态"><a href="#用户态和核心态" class="headerlink" title="用户态和核心态"></a>用户态和核心态</h2><p>Linux系统中分为核心态(Kernel model)和用户态(User model)，CPU会在两个model之间切换。</p><ol><li>核心态代码拥有完全的底层资源控制权限，可以执行任何CPU指令，访问任何内存地址，其占有的处理机是不允许被抢占的。内核态的指令包括：启动I/O，内存清零，修改程序状态字，设置时钟，允许/终止中断和停机。内核态的程序崩溃会导致PC停机。</li><li>用户态是用户程序能够使用的指令，不能直接访问底层硬件和内存地址。用户态运行的程序必须委托系统调用来访问硬件和内存。用户态的指令包括：控制转移，算数运算，取数指令，访管指令（使用户程序从用户态陷入内核态）。</li></ol><h3 id="用户态和核心态的切换"><a href="#用户态和核心态的切换" class="headerlink" title="用户态和核心态的切换"></a>用户态和核心态的切换</h3><p>用户态切换到核心态有三种方式：</p><p>a.系统调用<br>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p><p>b.异常<br>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p><p>c.外围设备的中断<br>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><hr><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ul><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ul><h2 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h2><hr><p>正在执行的进程由于一些事情发生，如请求资源失败、等待某种操作完成、新数据尚未达到或者没有新工作做等，由系统自动执行阻塞原语，使进程状态变为阻塞状态。因此，进程阻塞是进程自身的一种主动行为，只有处于运行中的进程才可以将自身转化为阻塞状态。<strong>当进程被阻塞，它是不占用CPU资源的。</strong></p><h2 id="文件描述符-fd-File-Descriptor"><a href="#文件描述符-fd-File-Descriptor" class="headerlink" title="文件描述符(fd, File Descriptor)"></a>文件描述符(fd, File Descriptor)</h2><hr><p>FD用于描述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h2 id="缓存I-O"><a href="#缓存I-O" class="headerlink" title="缓存I/O"></a>缓存I/O</h2><hr><p>缓存IO又被称作标准IO，大多数文件系统的默认IO 操作都是缓存IO。在Linux的缓存IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><h4 id="缓存IO的缺点："><a href="#缓存IO的缺点：" class="headerlink" title="缓存IO的缺点："></a>缓存IO的缺点：</h4><p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h2 id="Linux下的五种I-O模型"><a href="#Linux下的五种I-O模型" class="headerlink" title="Linux下的五种I/O模型"></a>Linux下的五种I/O模型</h2><hr><p>Linux下主要有以下五种I/O模型：</p><ol><li>阻塞I/O（blocking IO）</li><li>非阻塞I/O (nonblocking I/O)</li><li>I/O 复用 (I/O multiplexing)</li><li>信号驱动I/O (signal driven I/O (SIGIO))</li><li>异步I/O (asynchronous I/O)</li></ol><h3 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h3><p>进程会一直阻塞，直到数据拷贝完成 应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。数据准备好后，从内核拷贝到用户空间，IO函数返回成功指示。阻塞IO模型图如下所示：</p><img src="/2020/10/27/linux%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/image-1603765833.png" class="" title="some description"><h4 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h4><p>通过进程反复调用IO函数，在数据拷贝过程中，进程是阻塞的。模型图如下所示:</p><img src="/2020/10/27/linux%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/image-1603765852.png" class="" title="some description"><h4 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h4><p>主要是select和epoll。一个线程可以对多个IO端口进行监听，当socket有读写事件时分发到具体的线程进行处理。模型如下所示：</p><img src="/2020/10/27/linux%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/image-1603765870.png" class="" title="some description"><h4 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h4><p>信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。过程如下图所示：</p><img src="/2020/10/27/linux%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/image-1603765886.png" class="" title="some description"><h4 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h4><p>相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。异步过程如下图所示：</p><img src="/2020/10/27/linux%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/image-1603765906.png" class="" title="some description"><h2 id="五种IO模型比较"><a href="#五种IO模型比较" class="headerlink" title="五种IO模型比较"></a>五种IO模型比较</h2><h3 id="阻塞IO和非阻塞IO的区别"><a href="#阻塞IO和非阻塞IO的区别" class="headerlink" title="阻塞IO和非阻塞IO的区别"></a>阻塞IO和非阻塞IO的区别</h3><p>调用阻塞IO后进程会一直等待对应的进程完成，而非阻塞IO不会等待对应的进程完成，在kernel还在准备数据的情况下直接返回。 同步IO和异步IO的区别<br>首先看一下POSIX中对这两个IO的定义：</p><blockquote><p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>An asynchronous I/O operation does not cause the requesting process to be blocked;</p></blockquote><p><strong>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。</strong>按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。注意到non-blocking IO会一直轮询(polling)，这个过程是没有阻塞的，但是recvfrom阶段blocking IO,non-blocking IO和IO multiplexing都是阻塞的。<br>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><img src="/2020/10/27/linux%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/image-1603765975.png" class="" title="some description"><h2 id="IO复用之select、poll、epoll简介"><a href="#IO复用之select、poll、epoll简介" class="headerlink" title="IO复用之select、poll、epoll简介"></a>IO复用之select、poll、epoll简介</h2><hr><p>epoll是linux所特有，而select是POSIX所规定，一般操作系统均有实现。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select本质是通过设置或检查存放fd标志位的数据结构来进行下一步处理。缺点是：</p><ul><li>单个进程可监视的fd数量被限制，即能监听端口的大小有限。一般来说和系统内存有关，具体数目可以cat /proc/sys/fs/file-max察看。32位默认是1024个，64位默认为2048个</li><li>对socket进行扫描时是线性扫描，即采用轮询方法，效率低。当套接字比较多的时候，每次select()都要遍历FD_SETSIZE个socket来完成调度，不管socket是否活跃都遍历一遍。会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，就避免了轮询，这正是epoll与kqueue做的</li><li>需要维护一个用来存放大量fd的数据结构，会使得用户空间和内核空间在传递该结构时复制开销大</li></ul><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll本质和select相同，将用户传入的数据拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或主动超时，被唤醒后又要再次遍历fd。它没有最大连接数的限制，原因是它是基于链表来存储的，但缺点是：</p><ul><li>大量的fd的数组被整体复制到用户态和内核空间之间，不管有无意义。</li><li>poll还有一个特点“水平触发”，如果报告了fd后，没有被处理，那么下次poll时再次报告该ffd。</li></ul><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll支持水平触发和边缘触发，最大特点在于边缘触发，只告诉哪些fd刚刚变为就绪态，并且只通知一次。还有一特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一量该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。epoll的优点：</p><ul><li>没有最大并发连接的限制。</li><li>效率提升，只有活跃可用的FD才会调用callback函数。</li><li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递。</li></ul><h3 id="select、poll、epoll区别总结："><a href="#select、poll、epoll区别总结：" class="headerlink" title="select、poll、epoll区别总结："></a>select、poll、epoll区别总结：</h3><table><thead><tr><th>-</th><th>支持一个进程打开连接数</th><th>IO效率</th><th>消息传递方式</th></tr></thead><tbody><tr><td>select</td><td>32位机器1024个，64位2048个</td><td>IO效率低</td><td>内核需要将消息传递到用户空间，都需要内核拷贝动作</td></tr><tr><td>poll</td><td>无限制，原因基于链表存储</td><td>IO效率低</td><td>内核需要将消息传递到用户空间，都需要内核拷贝动作</td></tr><tr><td>epoll</td><td>有上限，但很大，2G内存20W左右</td><td>只有活跃的socket才调用callback，IO效率高</td><td>通过内核与用户空间共享一块内存来实现</td></tr></tbody></table><p>[参考资料]</p><p><a href="https://wangpengcheng.github.io/2019/11/10/unix_network_programming_01/">Unix网络编程</a></p><p><a href="https://en.wikipedia.org/wiki/File_descriptor">File descriptor</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 用户空间与内核空间</title>
    <link href="/2020/10/23/Linux%20%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/"/>
    <url>/2020/10/23/Linux%20%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="linux中的用户空间与内核空间"><a href="#linux中的用户空间与内核空间" class="headerlink" title="linux中的用户空间与内核空间"></a>linux中的用户空间与内核空间</h3><blockquote><p>在操作系统中，虚拟内存通常会被分成用户空间（英语：User space，又译为使用者空间），与核心空间（英语：Kernel space，又译为内核空间）这两个区块。<br>这是存储器保护机制中的一环。<br>内核、核心扩充（kernel extensions）、以及驱动程序，运行在核心空间上。<br>而其他的应用程序，则运行在用户空间上。<br>所有运行在用户空间的应用程序，都被统称为用户级（userland）。</p></blockquote><p>学习 Linux 时，经常可以看到两个词：User space（用户空间）和 Kernel space（内核空间）。</p><p>简单说，Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p><img src="/2020/10/23/Linux%20%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/image-1603462481.png" class="" title="some description"><p>Linux简化了分段机制，使得虚拟地址与线性地址总是一致，因此，Linux的虚拟地址空间也为0～4G。Linux内核将这4G字节的空间分为两部分：<br>将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”；<br>而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间  ）。</p><p>Kernel space 可以执行任意命令，调用系统的一切资源；User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">str = <span class="hljs-string">&quot;my string&quot;</span> <span class="hljs-comment">// 用户空间</span><br>x = x + <span class="hljs-number">1</span><br>file.write(str) <span class="hljs-comment">// 切换到内核空间</span><br><br>y = x + <span class="hljs-number">2</span> <span class="hljs-comment">// 切换回用户空间</span><br></code></pre></td></tr></table></figure><p>上面代码中，第一行和第二行都是简单的赋值运算，在 User space 执行。第三行需要写入文件，就要切换到 Kernel space，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回 User space。</p><p>查看 CPU 时间在 User space 与 Kernel Space 之间的分配情况，可以使用<code>top</code>命令。它的第三行输出就是 CPU 时间分配统计。</p><img src="/2020/10/23/Linux%20%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/image-1603463448.png" class="" title="some description"><p>其中，第一项0.0 us（user 的缩写）就是 CPU 消耗在 User space 的时间百分比，第二项3 .2 sy（system 的缩写）是消耗在 Kernel space 的时间百分比。</p><p>其他 6 个指标的含义如下:</p><ul><li>ni：niceness 的缩写，CPU 消耗在 nice 进程（低优先级）的时间百分比</li><li>id：idle 的缩写，CPU 消耗在闲置进程的时间百分比，这个值越低，表示 CPU 越忙</li><li>wa：wait 的缩写，CPU 等待外部 I/O 的时间百分比，这段时间 CPU 不能干其他事，但是也没有执行运算，这个值太高就说明外部设备有问题</li><li>hi：hardware interrupt 的缩写，CPU 响应硬件中断请求的时间百分比</li><li>si：software interrupt 的缩写，CPU 响应软件中断请求的时间百分比</li><li>st：stole time 的缩写，该项指标只对虚拟机有效，表示分配给当前虚拟机的 CPU 时间之中，被同一台物理机上的其他虚拟机偷走的时间百分比</li></ul><p>如果想查看单个程序的耗时，一般使用<code>time</code>命令。</p><p>程序名之前加上time命令，会在程序执行完毕以后，默认显示三行统计。</p><ul><li>real：程序从开始运行到结束的全部时间，这是用户能感知到的时间，包括 CPU 切换去执行其他任务的时间。</li><li>user：程序在 User space 执行的时间</li><li>sys：程序在 Kernel space 执行的时间</li></ul><p>user和sys之和，一般情况下，应该小于real。但如果是多核 CPU，这两个指标反映的是所有 CPU 的总耗时，所以它们之和可能大于real。</p><p>[参考资料]<br><a href="http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html">User space 与 Kernel space</a><br><a href="https://blog.csdn.net/zhangskd/article/details/6956638">User space</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>karnel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubesphere 安装与部署</title>
    <link href="/2020/10/13/kubesphere-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/10/13/kubesphere-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<blockquote><h1 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h1></blockquote><blockquote><p>Kubernetes版本： 1.15.x ≤ K8s version ≤ 1.17.x；<br>Helm版本： 2.10.0 ≤ Helm Version ＜ 3.0.0，建议使用 Helm 2.16.2（不支持 helm 2.16.0 #6894），且已安装了 Tiller，参考 如何安装与配置 Helm （预计 3.0 支持 Helm v3）；<br>集群已有默认的存储类型（StorageClass），若还没有准备存储请参考 安装 OpenEBS 创建 LocalPV 存储类型 用作开发测试环境。<br>集群能够访问外网，若无外网请参考 在 Kubernetes 离线安装 KubeSphere。</p></blockquote><blockquote><p>All-in-One 模式<br>对于首次接触 KubeSphere 的用户，想寻找一个最快安装和体验 KubeSphere 的方式，all-in-one 模式可一键安装 <strong>KubeSphere</strong> 和 <strong>Kubernetes</strong> 至一台目标机器。</p></blockquote><ul><li><p><font color='pink'>KubeSphere 2.1 默认仅开启最小化安装，Installer 已支持自定义安装各个可插拔的功能组件，用户可根据业务需求和机器配置选择安装所需的组件，请确保开启可插拔组件之前机器资源满足最低要求，参考<a href="https://v2-1.docs.kubesphere.io/docs/zh-CN/installation/intro/#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%89%E8%A3%85%E5%8F%AF%E6%8F%92%E6%8B%94%E7%9A%84%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6"> <strong>安装说明</strong> </a>开启可选组件的安装。</font></p></li><li><p><font color='pink'>若您的机器资源配置充足（CPU 不小于 8 核，内存不小于 16 G），非常建议您在安装前 将<a href="https://v2-1.docs.kubesphere.io/docs/zh-CN/installation/complete-installation"> <strong>KubeSphere 所有功能组件都开启</strong></a> 后再执行安装，体验 KubeSphere 容器平台端到端完整的容器管理与运维能力。</font></p></li><li><p><font color='pink'>安装时间跟网络情况和带宽、机器配置、安装节点个数等因素有关，可通过调高带宽的方式，或在安装前 配置<a href="https://kubesphere.com.cn/forum/d/149-kubesphere-v2-1-0"><strong>镜像加速器</strong></a> 来加快安装速度。</font></p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi helm-rbac.yaml<br><br><span class="hljs-comment">#### helm-rbac.yaml start</span><br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: tiller<br>  namespace: kube-system<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: tiller<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: cluster-admin<br>subjects:<br>  - kind: ServiceAccount<br>    name: tiller<br>    namespace: kube-system<br> <span class="hljs-comment">#### helm-rbac.yaml end</span><br><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 需要开启代理</span><br>curl -L https://git.io/get_helm.sh | bash<br><span class="hljs-comment">#关闭代理后执行</span><br>kubectl apply -f helm-rbac.yaml<br><br></code></pre></td></tr></table></figure><img src="/2020/10/13/kubesphere-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/image-1602575029.png" class="" title="some description"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">helm init --service-account=tiller -- tiller-image=sapcc/tiller:v2.16.3 --history-max 300<br><span class="hljs-comment"># 给master k8s-node1 去除污点 </span><br>kubectl taint nodes $(hostname) node-role.kubernetes.io/master:NoSchedule-<br></code></pre></td></tr></table></figure><img src="/2020/10/13/kubesphere-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/image-1602578327.png" class="" title="some description"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl create ns openebs<br><span class="hljs-comment"># 安装openebs 作为默认存储</span><br> helm install --namespace openebs --name openebs stable/openebs --version 1.5.0<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 设置默认StorageClass</span><br>kubectl patch storageclass openebs-hostpath -p <span class="hljs-string">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><img src="/2020/10/13/kubesphere-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/image-1602577862.png" class="" title="some description"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#给master k8s-node1 添加污点</span><br>kubectl taint nodes master1 node-role.kubernetes.io/master=:NoSchedule<br></code></pre></td></tr></table></figure><p>至此，StorageClass 安装完毕</p><h1 id="部署-KubeSphere"><a href="#部署-KubeSphere" class="headerlink" title="部署 KubeSphere"></a>部署 KubeSphere</h1><h2 id="最小化快速部署"><a href="#最小化快速部署" class="headerlink" title="最小化快速部署"></a>最小化快速部署</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f https://raw.githubusercontent.com/kubesphere/ks-installer/v2.1.1/deploy/kubesphere-installer.yaml<br></code></pre></td></tr></table></figure><img src="/2020/10/13/kubesphere-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/image-1602581460.png" class="" title="some description"><p>Inspect the logs of installation.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l app=ks-install -o jsonpath=<span class="hljs-string">&#x27;&#123;.items[0].metadata.name&#125;&#x27;</span>) -f<br></code></pre></td></tr></table></figure><img src="/2020/10/13/kubesphere-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/image-1602581661.png" class="" title="some description"><p>admin/P@88w0rd 登录</p><img src="/2020/10/13/kubesphere-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/image-1602649614.png" class="" title="some description"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#添加污点</span><br>kubectl taint nodes k8s-node1 node-role.kubernetes.io/master=:NoSchedule<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>k8s</tag>
      
      <tag>k8s-cluster</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s Devops环境搭建准备</title>
    <link href="/2020/10/12/K8s%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"/>
    <url>/2020/10/12/K8s%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h2 id="1-安装依赖-vagrant-和virtual-box"><a href="#1-安装依赖-vagrant-和virtual-box" class="headerlink" title="1.安装依赖 vagrant 和virtual box"></a>1.安装依赖 vagrant 和virtual box</h2><p>创建文件 vagrantfile<br>以下是文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">Vagrant.configure(<span class="hljs-string">&quot;2&quot;</span>) <span class="hljs-keyword">do</span> |config|<br>   (1..3).each <span class="hljs-keyword">do</span> |i|<br>        config.vm.define <span class="hljs-string">&quot;k8s-node#&#123;i&#125;&quot;</span> <span class="hljs-keyword">do</span> |node|<br>            <span class="hljs-comment"># 设置虚拟机的Box</span><br>            node.vm.box = <span class="hljs-string">&quot;centos/7&quot;</span><br><br>            <span class="hljs-comment"># 设置虚拟机的主机名</span><br>            node.vm.hostname=<span class="hljs-string">&quot;k8s-node#&#123;i&#125;&quot;</span><br><br>            <span class="hljs-comment"># 设置虚拟机的IP</span><br>            node.vm.network <span class="hljs-string">&quot;private_network&quot;</span>, ip: <span class="hljs-string">&quot;192.168.56.#&#123;99+i&#125;&quot;</span>, netmask: <span class="hljs-string">&quot;255.255.255.0&quot;</span><br><br>            <span class="hljs-comment"># 设置主机与虚拟机的共享目录</span><br>            <span class="hljs-comment"># node.vm.synced_folder &quot;~/Documents/vagrant/share&quot;, &quot;/home/vagrant/share&quot;</span><br><br>            <span class="hljs-comment"># VirtaulBox相关配置</span><br>            node.vm.provider <span class="hljs-string">&quot;virtualbox&quot;</span> <span class="hljs-keyword">do</span> |v|<br>                <span class="hljs-comment"># 设置虚拟机的名称</span><br>                v.name = <span class="hljs-string">&quot;k8s-node#&#123;i&#125;&quot;</span><br>                <span class="hljs-comment"># 设置虚拟机的内存大小</span><br>                v.memory = 4096<br>                <span class="hljs-comment"># 设置虚拟机的CPU个数</span><br>                v.cpus = 4<br>            end<br>        end<br>   end<br>end<br></code></pre></td></tr></table></figure><p>然后执行 vagrant up</p><p>设置每一个虚拟机的网络环境</p><img src="/2020/10/12/K8s%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-1602495143.png" class="" title="some description"><p><font color='red'>连接方式需要变成NAT网络<br><strong>每一个虚拟机的mac 地址需要刷新重新生成</strong><br></font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检查eth0 ip</span><br>ip route show<br><span class="hljs-comment"># 确认eth0 对应的ip 在每个虚拟机不一样</span><br>ip addr<br><span class="hljs-comment"># 测试能否联通其他虚拟机</span><br>ping 10.0.2.5<br><span class="hljs-comment">#测试能否联通外网</span><br>ping baidu.com<br></code></pre></td></tr></table></figure><p><strong>进入每一台虚拟机 开启密码访问登录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">vagrant ssh k8s-node1<br>su root<br>vi /etc/ssh/sshd_config<br><span class="hljs-comment"># 输入i 进入编辑模式</span><br><span class="hljs-comment"># 更改 PasswordAuthentication no 设成yes</span><br><span class="hljs-comment"># 方便远程可以通过用户密码的方式登录</span><br>PasswordAuthentication yes<br><span class="hljs-comment">#编辑后按ESC 输入wq 保存并退出</span><br><span class="hljs-comment"># 重启sshd 服务 让其生效</span><br>service sshd restart<br></code></pre></td></tr></table></figure><p>通过ssh 登录各个虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭防火墙</span><br>systemctl stop firewalld<br><span class="hljs-comment"># 禁用防火墙</span><br>systemctl <span class="hljs-built_in">disable</span> firewalld<br><span class="hljs-comment">#关闭linux安全策略</span><br>sed -i <span class="hljs-string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config<br>setenforce 0<br></code></pre></td></tr></table></figure><img src="/2020/10/12/K8s%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-1602497147.png" class="" title="some description"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#（1）临时关闭swap分区, 重启失效;</span><br>swapoff -a<br><br><span class="hljs-comment">#（2）永久关闭swap分区</span><br>sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab<br></code></pre></td></tr></table></figure><p>添加主机名与ip对应关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/hosts<br><br>10.0.2.5 k8s-node1<br>10.0.2.4 k8s-node2<br>10.0.2.15 k8s-node3<br><br><span class="hljs-comment"># 如果主机名没设置对</span><br>hostnamectl set-hostname &lt;newhostname&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 桥接的ipv4 流量传递到iptables</span><br>cat &gt;/etc/sysctl.d/k8s.conf &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables =1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables =1</span><br><span class="hljs-string">EOF</span><br>sysctl --system<br><br></code></pre></td></tr></table></figure><img src="/2020/10/12/K8s%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-1602498926.png" class="" title="some description"><h2 id="2-k8s-集群搭建-安装Docker、kubelet、kubeadm、kubectl"><a href="#2-k8s-集群搭建-安装Docker、kubelet、kubeadm、kubectl" class="headerlink" title="2. k8s-集群搭建-安装Docker、kubelet、kubeadm、kubectl"></a>2. k8s-集群搭建-安装Docker、kubelet、kubeadm、kubectl</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 卸载原来的docker</span><br>sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br><br><span class="hljs-comment"># 安装依赖</span><br>sudo yum update -y &amp;&amp; sudo yum install -y yum-utils \<br>  device-mapper-persistent-data \<br>  lvm2<br>  <br><span class="hljs-comment"># 添加官方yum库</span><br>sudo yum-config-manager \<br>    --add-repo \<br>    https://download.docker.com/linux/centos/docker-ce.repo<br>    <br><span class="hljs-comment"># 安装docker</span><br>sudo yum install docker-ce docker-ce-cli containerd.io<br><br><span class="hljs-comment"># 查看docker版本</span><br>docker --version<br><br><span class="hljs-comment"># 开机启动</span><br>systemctl <span class="hljs-built_in">enable</span> --now docker<br><br><br></code></pre></td></tr></table></figure><p>添加docker加速</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://yourcode.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#更换yum 源为aliyun</span><br>cat &lt;&lt;<span class="hljs-string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="hljs-string">[kubernetes]</span><br><span class="hljs-string">name=Kubernetes</span><br><span class="hljs-string">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="hljs-string">enabled=1</span><br><span class="hljs-string">gpgcheck=0</span><br><span class="hljs-string">repo_gpgcheck=0</span><br><span class="hljs-string">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="hljs-string">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y kubelet-1.17.3 kubeadm-1.17.3 kubectl-1.17.3<br>systemctl <span class="hljs-built_in">enable</span> kubelet<br>systemctl start kubelet<br></code></pre></td></tr></table></figure><h2 id="3-k8s-master节点安装"><a href="#3-k8s-master节点安装" class="headerlink" title="3. k8s master节点安装"></a>3. k8s master节点安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubeadm init \<br>        --apiserver-advertise-address 10.0.2.5 \<br>        --cert-dir /etc/kubernetes/pki \<br>        --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers \<br>        --kubernetes-version 1.17.3 \<br>        --pod-network-cidr 10.244.0.0/16 \<br>        --service-cidr 10.96.0.0/16 \<br></code></pre></td></tr></table></figure><p>在master节点执行文件， 执行文件前设置文件可执行(700)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>images=(<br>kube-apiserver:v1.17.3<br>    kube-proxy:v1.17.3<br>kube-controller-manager:v1.17.3<br>kube-scheduler:v1.17.3<br>coredns:1.6.5<br>etcd:3.4.3-0<br>    pause:3.1<br>)<br><br><span class="hljs-keyword">for</span> imageName <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;images[@]&#125;</span> ; <span class="hljs-keyword">do</span><br>    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/<span class="hljs-variable">$imageName</span><br><span class="hljs-comment">#   docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName  k8s.gcr.io/$imageName</span><br><span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure><img src="/2020/10/12/K8s%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-1602504308.png" class="" title="some description"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkdir -p <span class="hljs-variable">$HOME</span>/.kube<br> sudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config<br> sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config<br></code></pre></td></tr></table></figure><p><strong>添加一个网络在master node将下面抽取成一个yml文件执行<br>kubectl apply -f xxxx.yml</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br></pre></td><td class="code"><pre><code class="hljs sh">---<br>apiVersion: policy/v1beta1<br>kind: PodSecurityPolicy<br>metadata:<br>  name: psp.flannel.unprivileged<br>  annotations:<br>    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default<br>    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default<br>    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default<br>    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default<br>spec:<br>  privileged: <span class="hljs-literal">false</span><br>  volumes:<br>    - configMap<br>    - secret<br>    - emptyDir<br>    - hostPath<br>  allowedHostPaths:<br>    - pathPrefix: <span class="hljs-string">&quot;/etc/cni/net.d&quot;</span><br>    - pathPrefix: <span class="hljs-string">&quot;/etc/kube-flannel&quot;</span><br>    - pathPrefix: <span class="hljs-string">&quot;/run/flannel&quot;</span><br>  readOnlyRootFilesystem: <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># Users and groups</span><br>  runAsUser:<br>    rule: RunAsAny<br>  supplementalGroups:<br>    rule: RunAsAny<br>  fsGroup:<br>    rule: RunAsAny<br>  <span class="hljs-comment"># Privilege Escalation</span><br>  allowPrivilegeEscalation: <span class="hljs-literal">false</span><br>  defaultAllowPrivilegeEscalation: <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># Capabilities</span><br>  allowedCapabilities: [<span class="hljs-string">&#x27;NET_ADMIN&#x27;</span>]<br>  defaultAddCapabilities: []<br>  requiredDropCapabilities: []<br>  <span class="hljs-comment"># Host namespaces</span><br>  hostPID: <span class="hljs-literal">false</span><br>  hostIPC: <span class="hljs-literal">false</span><br>  hostNetwork: <span class="hljs-literal">true</span><br>  hostPorts:<br>  - min: 0<br>    max: 65535<br>  <span class="hljs-comment"># SELinux</span><br>  seLinux:<br>    <span class="hljs-comment"># SELinux is unused in CaaSP</span><br>    rule: <span class="hljs-string">&#x27;RunAsAny&#x27;</span><br>---<br>kind: ClusterRole<br>apiVersion: rbac.authorization.k8s.io/v1beta1<br>metadata:<br>  name: flannel<br>rules:<br>  - apiGroups: [<span class="hljs-string">&#x27;extensions&#x27;</span>]<br>    resources: [<span class="hljs-string">&#x27;podsecuritypolicies&#x27;</span>]<br>    verbs: [<span class="hljs-string">&#x27;use&#x27;</span>]<br>    resourceNames: [<span class="hljs-string">&#x27;psp.flannel.unprivileged&#x27;</span>]<br>  - apiGroups:<br>      - <span class="hljs-string">&quot;&quot;</span><br>    resources:<br>      - pods<br>    verbs:<br>      - get<br>  - apiGroups:<br>      - <span class="hljs-string">&quot;&quot;</span><br>    resources:<br>      - nodes<br>    verbs:<br>      - list<br>      - watch<br>  - apiGroups:<br>      - <span class="hljs-string">&quot;&quot;</span><br>    resources:<br>      - nodes/status<br>    verbs:<br>      - patch<br>---<br>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1beta1<br>metadata:<br>  name: flannel<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: flannel<br>subjects:<br>- kind: ServiceAccount<br>  name: flannel<br>  namespace: kube-system<br>---<br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: flannel<br>  namespace: kube-system<br>---<br>kind: ConfigMap<br>apiVersion: v1<br>metadata:<br>  name: kube-flannel-cfg<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>data:<br>  cni-conf.json: |<br>    &#123;<br>      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;cbr0&quot;</span>,<br>      <span class="hljs-string">&quot;cniVersion&quot;</span>: <span class="hljs-string">&quot;0.3.1&quot;</span>,<br>      <span class="hljs-string">&quot;plugins&quot;</span>: [<br>        &#123;<br>          <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;flannel&quot;</span>,<br>          <span class="hljs-string">&quot;delegate&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;hairpinMode&quot;</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-string">&quot;isDefaultGateway&quot;</span>: <span class="hljs-literal">true</span><br>          &#125;<br>        &#125;,<br>        &#123;<br>          <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;portmap&quot;</span>,<br>          <span class="hljs-string">&quot;capabilities&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;portMappings&quot;</span>: <span class="hljs-literal">true</span><br>          &#125;<br>        &#125;<br>      ]<br>    &#125;<br>  net-conf.json: |<br>    &#123;<br>      <span class="hljs-string">&quot;Network&quot;</span>: <span class="hljs-string">&quot;10.244.0.0/16&quot;</span>,<br>      <span class="hljs-string">&quot;Backend&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;Type&quot;</span>: <span class="hljs-string">&quot;vxlan&quot;</span><br>      &#125;<br>    &#125;<br>---<br>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-amd64<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: beta.kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: beta.kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - amd64<br>      hostNetwork: <span class="hljs-literal">true</span><br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.11.0-amd64<br>        <span class="hljs-built_in">command</span>:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.11.0-amd64<br>        <span class="hljs-built_in">command</span>:<br>        - /opt/bin/flanneld<br>        args:<br>        - --ip-masq<br>        - --kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: <span class="hljs-string">&quot;100m&quot;</span><br>            memory: <span class="hljs-string">&quot;50Mi&quot;</span><br>          limits:<br>            cpu: <span class="hljs-string">&quot;100m&quot;</span><br>            memory: <span class="hljs-string">&quot;50Mi&quot;</span><br>        securityContext:<br>          privileged: <span class="hljs-literal">false</span><br>          capabilities:<br>            add: [<span class="hljs-string">&quot;NET_ADMIN&quot;</span>]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg<br>---<br>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-arm64<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: beta.kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: beta.kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - arm64<br>      hostNetwork: <span class="hljs-literal">true</span><br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.11.0-arm64<br>        <span class="hljs-built_in">command</span>:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.11.0-arm64<br>        <span class="hljs-built_in">command</span>:<br>        - /opt/bin/flanneld<br>        args:<br>        - --ip-masq<br>        - --kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: <span class="hljs-string">&quot;100m&quot;</span><br>            memory: <span class="hljs-string">&quot;50Mi&quot;</span><br>          limits:<br>            cpu: <span class="hljs-string">&quot;100m&quot;</span><br>            memory: <span class="hljs-string">&quot;50Mi&quot;</span><br>        securityContext:<br>          privileged: <span class="hljs-literal">false</span><br>          capabilities:<br>             add: [<span class="hljs-string">&quot;NET_ADMIN&quot;</span>]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg<br>---<br>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-arm<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: beta.kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: beta.kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - arm<br>      hostNetwork: <span class="hljs-literal">true</span><br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.11.0-arm<br>        <span class="hljs-built_in">command</span>:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.11.0-arm<br>        <span class="hljs-built_in">command</span>:<br>        - /opt/bin/flanneld<br>        args:<br>        - --ip-masq<br>        - --kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: <span class="hljs-string">&quot;100m&quot;</span><br>            memory: <span class="hljs-string">&quot;50Mi&quot;</span><br>          limits:<br>            cpu: <span class="hljs-string">&quot;100m&quot;</span><br>            memory: <span class="hljs-string">&quot;50Mi&quot;</span><br>        securityContext:<br>          privileged: <span class="hljs-literal">false</span><br>          capabilities:<br>             add: [<span class="hljs-string">&quot;NET_ADMIN&quot;</span>]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg<br>---<br>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-ppc64le<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: beta.kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: beta.kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - ppc64le<br>      hostNetwork: <span class="hljs-literal">true</span><br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.11.0-ppc64le<br>        <span class="hljs-built_in">command</span>:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.11.0-ppc64le<br>        <span class="hljs-built_in">command</span>:<br>        - /opt/bin/flanneld<br>        args:<br>        - --ip-masq<br>        - --kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: <span class="hljs-string">&quot;100m&quot;</span><br>            memory: <span class="hljs-string">&quot;50Mi&quot;</span><br>          limits:<br>            cpu: <span class="hljs-string">&quot;100m&quot;</span><br>            memory: <span class="hljs-string">&quot;50Mi&quot;</span><br>        securityContext:<br>          privileged: <span class="hljs-literal">false</span><br>          capabilities:<br>             add: [<span class="hljs-string">&quot;NET_ADMIN&quot;</span>]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg<br>---<br>apiVersion: apps/v1<br>kind: DaemonSet<br>metadata:<br>  name: kube-flannel-ds-s390x<br>  namespace: kube-system<br>  labels:<br>    tier: node<br>    app: flannel<br>spec:<br>  selector:<br>    matchLabels:<br>      app: flannel<br>  template:<br>    metadata:<br>      labels:<br>        tier: node<br>        app: flannel<br>    spec:<br>      affinity:<br>        nodeAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            nodeSelectorTerms:<br>              - matchExpressions:<br>                  - key: beta.kubernetes.io/os<br>                    operator: In<br>                    values:<br>                      - linux<br>                  - key: beta.kubernetes.io/arch<br>                    operator: In<br>                    values:<br>                      - s390x<br>      hostNetwork: <span class="hljs-literal">true</span><br>      tolerations:<br>      - operator: Exists<br>        effect: NoSchedule<br>      serviceAccountName: flannel<br>      initContainers:<br>      - name: install-cni<br>        image: quay.io/coreos/flannel:v0.11.0-s390x<br>        <span class="hljs-built_in">command</span>:<br>        - cp<br>        args:<br>        - -f<br>        - /etc/kube-flannel/cni-conf.json<br>        - /etc/cni/net.d/10-flannel.conflist<br>        volumeMounts:<br>        - name: cni<br>          mountPath: /etc/cni/net.d<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      containers:<br>      - name: kube-flannel<br>        image: quay.io/coreos/flannel:v0.11.0-s390x<br>        <span class="hljs-built_in">command</span>:<br>        - /opt/bin/flanneld<br>        args:<br>        - --ip-masq<br>        - --kube-subnet-mgr<br>        resources:<br>          requests:<br>            cpu: <span class="hljs-string">&quot;100m&quot;</span><br>            memory: <span class="hljs-string">&quot;50Mi&quot;</span><br>          limits:<br>            cpu: <span class="hljs-string">&quot;100m&quot;</span><br>            memory: <span class="hljs-string">&quot;50Mi&quot;</span><br>        securityContext:<br>          privileged: <span class="hljs-literal">false</span><br>          capabilities:<br>             add: [<span class="hljs-string">&quot;NET_ADMIN&quot;</span>]<br>        env:<br>        - name: POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.name<br>        - name: POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              fieldPath: metadata.namespace<br>        volumeMounts:<br>        - name: run<br>          mountPath: /run/flannel<br>        - name: flannel-cfg<br>          mountPath: /etc/kube-flannel/<br>      volumes:<br>        - name: run<br>          hostPath:<br>            path: /run/flannel<br>        - name: cni<br>          hostPath:<br>            path: /etc/cni/net.d<br>        - name: flannel-cfg<br>          configMap:<br>            name: kube-flannel-cfg<br></code></pre></td></tr></table></figure><p>在node 执行加入master</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubeadm join 10.0.2.5:6443 --token vi3lq8.vze5hodae0oufto2 \<br>    --discovery-token-ca-cert-hash sha256:25518d08b8a03076f808200b2de973b089c7b04b877d9fbc51a9c5139d141180<br></code></pre></td></tr></table></figure><img src="/2020/10/12/K8s%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/image-1602505559.png" class="" title="some description"><p>至此, k8s 集群的基础环境搭建完成。<br>接下来会介绍如何搭建kubesphere。</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>k8s</tag>
      
      <tag>k8s-cluster</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel 的使用</title>
    <link href="/2020/10/09/Sentinel-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/10/09/Sentinel-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ol><li>引入 Sentinel 依赖<br>如果您的应用使用了 Maven，则在 pom.xml 文件中加入以下代码即可：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p>下面这个例子就是一个最简单的使用 Sentinel 的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ServiceApplication.class, args);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestService</span> </span>&#123;<br><br>    <span class="hljs-meta">@SentinelResource(value = &quot;sayHello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TestService service;<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/hello/&#123;name&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apiHello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> service.sayHello(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@SentinelResource 注解用来标识资源是否被限流、降级。上述例子上该注解的属性 sayHello 表示资源名。</p><p>@SentinelResource 还提供了其它额外的属性如 blockHandler，blockHandlerClass，fallback 用于表示限流或降级的操作（注意有方法签名要求），更多内容可以参考 Sentinel 注解支持文档。若不配置 blockHandler、fallback 等函数，则被流控降级时方法会直接抛出对应的 BlockException；若方法未定义 throws BlockException 则会被 JVM 包装一层 UndeclaredThrowableException。</p><blockquote><p>注：一般推荐将 @SentinelResource 注解加到服务实现上，而在 Web 层直接使用 Spring Cloud Alibaba 自带的 Web 埋点适配。Sentinel Web 适配同样支持配置自定义流控处理逻辑，参考 相关文档。</p></blockquote><p>Sentinel 控制台<br>Sentinel 控制台提供一个轻量级的控制台，它提供机器发现、单机资源实时监控、集群资源汇总，以及规则管理的功能。您只需要对应用进行简单的配置，就可以使用这些功能。</p><p><strong>注意:</strong> 集群资源汇总仅支持 500 台以下的应用集群，有大概 1 - 2 秒的延时。</p><img src="/2020/10/09/Sentinel-%E7%9A%84%E4%BD%BF%E7%94%A8/image-1602236063.png" class="" title="some description"><p>Figure 1. Sentinel Dashboard<br>开启该功能需要3个步骤：</p><p>获取控制台<br>您可以从 release 页面 下载最新版本的控制台 jar 包。</p><p>您也可以从最新版本的源码自行构建 Sentinel 控制台：</p><p>下载 控制台 工程</p><p>使用以下命令将代码打包成一个 fat jar: mvn clean package</p><p>启动控制台<br>Sentinel 控制台是一个标准的 Spring Boot 应用，以 Spring Boot 的方式运行 jar 包即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar<br><br></code></pre></td></tr></table></figure><p>如若8080端口冲突，可使用 -Dserver.port=新端口 进行设置</p><h3 id="配置控制台信息"><a href="#配置控制台信息" class="headerlink" title="配置控制台信息"></a>配置控制台信息</h3><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8719</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure><p>这里的 spring.cloud.sentinel.transport.port 端口配置会在应用对应的机器上启动一个 Http Server，该 Server 会与 Sentinel 控制台做交互。比如 Sentinel 控制台添加了一个限流规则，会把规则数据 push 给这个 Http Server 接收，Http Server 再将规则注册到 Sentinel 中。</p><p>更多 Sentinel 控制台的使用及问题参考： Sentinel 控制台文档 以及 Sentinel FAQ</p><p>Feign 支持<br>Sentinel 适配了 Feign 组件。如果想使用，除了引入 spring-cloud-starter-alibaba-sentinel 的依赖外还需要 2 个步骤：</p><ul><li><p>配置文件打开 Sentinel 对 Feign 的支持：feign.sentinel.enabled=true</p></li><li><p>加入 spring-cloud-starter-openfeign 依赖使 Sentinel starter 中的自动化配置类生效：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是一个 FeignClient 的简单使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;service-provider&quot;, fallback = EchoServiceFallback.class, configuration = FeignConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EchoService</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/echo/&#123;str&#125;&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-function">String <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;str&quot;)</span> String str)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> EchoServiceFallback <span class="hljs-title">echoServiceFallback</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EchoServiceFallback();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServiceFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EchoService</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;str&quot;)</span> String str)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;echo fallback&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>Feign 对应的接口中的资源名策略定义：httpmethod:protocol://requesturl。@FeignClient 注解中的所有属性，Sentinel 都做了兼容<br><em>EchoService</em> 接口中方法 echo 对应的资源名为 GET:<a href="http://service-provider/echo/%7Bstr%7D%E3%80%82">http://service-provider/echo/{str}。</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>从0到1手写一个RPC实现</title>
    <link href="/2020/10/08/%E4%BB%8E0%E5%88%B01%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AARPC%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/10/08/%E4%BB%8E0%E5%88%B01%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AARPC%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计划从0到1手写一个RPC的实现"><a href="#计划从0到1手写一个RPC的实现" class="headerlink" title="计划从0到1手写一个RPC的实现"></a>计划从0到1手写一个RPC的实现</h1><p>我准备把具体实现和想法记录下来，对学习其他RPC框架有一个参考和比较。<br>可能用到的技术栈：</p><blockquote><ul><li><code>spring</code></li></ul></blockquote><ul><li><code>netty</code></li><li><code>kryo, protobuf, thrift, hessian</code> (序列化和反序列化)</li><li><code>zookeeper, etcd, redis</code> (服务注册和发现)</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>rpc</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS</title>
    <link href="/2020/10/08/AQS/"/>
    <url>/2020/10/08/AQS/</url>
    
    <content type="html"><![CDATA[<h1 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1 ReentrantLock"></a>1 ReentrantLock</h1><h3 id="1-1-ReentrantLock特性概览"><a href="#1-1-ReentrantLock特性概览" class="headerlink" title="1.1 ReentrantLock特性概览"></a>1.1 ReentrantLock特性概览</h3><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下:<br><img src="https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// **************************Synchronized的使用方式**************************</span><br><span class="hljs-comment">// 1.用于代码块</span><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;&#125;<br><span class="hljs-comment">// 2.用于对象</span><br><span class="hljs-keyword">synchronized</span> (object) &#123;&#125;<br><span class="hljs-comment">// 3.用于方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span> <span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-comment">// 4.可重入</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;&#125;<br>&#125;<br><span class="hljs-comment">// **************************ReentrantLock的使用方式**************************</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span> <span class="hljs-params">()</span> throw Exception </span>&#123;<br><span class="hljs-comment">// 1.初始化选择公平锁、非公平锁</span><br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);<br><span class="hljs-comment">// 2.可用于代码块</span><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span><br><span class="hljs-keyword">if</span>(lock.tryLock(<span class="hljs-number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 4.手动释放锁</span><br>lock.unlock()<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-ReentrantLock与AQS的关联"><a href="#1-2-ReentrantLock与AQS的关联" class="headerlink" title="1.2 ReentrantLock与AQS的关联"></a>1.2 ReentrantLock与AQS的关联</h3><p>非公平锁源码中的加锁流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.ReentrantLock#NonfairSync</span><br><br><span class="hljs-comment">// 非公平锁</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>...<br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">else</span><br>acquire(<span class="hljs-number">1</span>);<br>&#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这块代码的含义为：</p><ul><li><p>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</p></li><li><p>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</p></li></ul><p>第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考：</p><p>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：<br>(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。</p><p>(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><p>对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><p>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p><p>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</p><p>带着非公平锁的这些问题，再看下公平锁源码中获锁的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.ReentrantLock#FairSync</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>  ...  <br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>acquire(<span class="hljs-number">1</span>);<br>&#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这块代码，我们可能会存在这种疑问：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。</p><p>对于上边提到的问题，其实在ReentrantLock类源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。</p><h1 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2 AQS"></a>2 AQS</h1><p>首先，我们通过下面的架构图来整体了解一下AQS框架：</p><img src="/2020/10/08/AQS/struct-aqs.png" class="" title="some description"><p>上图中有颜色的为Method，无颜色的为Attribution。</p><p>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</p><p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</p><p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：</p><img src="/2020/10/08/AQS/image-1602226897.png" class="" title="some description"><h3 id="2-1-原理概览"><a href="#2-1-原理概览" class="headerlink" title="2.1 原理概览"></a>2.1 原理概览</h3><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p><p>主要原理图如下：</p><img src="/2020/10/08/AQS/image-1602226949.png" class="" title="some description"><p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><h3 id="2-1-1-AQS数据结构"><a href="#2-1-1-AQS数据结构" class="headerlink" title="2.1.1 AQS数据结构"></a>2.1.1 AQS数据结构</h3><p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p><img src="/2020/10/08/AQS/image-1602226980.png" class="" title="some description"><p>解释一下几个方法和属性值的含义：</p><img src="/2020/10/08/AQS/image-1602227154.png" class="" title="some description"><p>线程两种锁的模式：</p><img src="/2020/10/08/AQS/image-1602227175.png" class="" title="some description"><p>waitStatus有下面几个枚举值：</p><img src="/2020/10/08/AQS/image-1602227193.png" class="" title="some description"><h3 id="2-1-2-同步状态State"><a href="#2-1-2-同步状态State" class="headerlink" title="2.1.2 同步状态State"></a>2.1.2 同步状态State</h3><p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br></code></pre></td></tr></table></figure><p>下面提供了几个访问这个字段的方法：</p><img src="/2020/10/08/AQS/image-1602227263.png" class="" title="some description"><p>这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p><img src="/2020/10/08/AQS/image-1602227277.png" class="" title="some description"><p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p><h2 id="2-2-AQS重要方法与ReentrantLock的关联"><a href="#2-2-AQS重要方法与ReentrantLock的关联" class="headerlink" title="2.2 AQS重要方法与ReentrantLock的关联"></a>2.2 AQS重要方法与ReentrantLock的关联</h2><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p><img src="/2020/10/08/AQS/image-1602227311.png" class="" title="some description"><p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p><p>以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。</p><img src="/2020/10/08/AQS/image-1602227326.png" class="" title="some description"><p>为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。</p><img src="/2020/10/08/AQS/image-1602227337.png" class="" title="some description"><p>加锁：</p><ul><li><p>通过ReentrantLock的加锁方法Lock进行加锁操作。</p></li><li><p>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</p></li><li><p>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</p></li><li><p>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。<br>解锁：</p></li><li><p>通过ReentrantLock的解锁方法Unlock进行解锁。</p></li><li><p>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</p></li><li><p>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</p></li><li><p>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</p></li></ul><p>通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。</p><img src="/2020/10/08/AQS/image-1602227426.png" class="" title="some description"><h2 id="2-3-通过ReentrantLock理解AQS"><a href="#2-3-通过ReentrantLock理解AQS" class="headerlink" title="2.3 通过ReentrantLock理解AQS"></a>2.3 通过ReentrantLock理解AQS</h2><p>ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p><p>在非公平锁中，有一段这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.ReentrantLock</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>...<br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>setExclusiveOwnerThread(Thread.currentThread());<br><span class="hljs-keyword">else</span><br>acquire(<span class="hljs-number">1</span>);<br>&#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>看一下这个Acquire是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>再看一下tryAcquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。</p><h3 id="2-3-1-线程加入等待队列"><a href="#2-3-1-线程加入等待队列" class="headerlink" title="2.3.1 线程加入等待队列"></a>2.3.1 线程加入等待队列</h3><h4 id="2-3-1-1-加入队列的时机"><a href="#2-3-1-1-加入队列的时机" class="headerlink" title="2.3.1.1 加入队列的时机"></a>2.3.1.1 加入队列的时机</h4><p>当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</p><h4 id="2-3-1-2-如何加入队列"><a href="#2-3-1-2-如何加入队列" class="headerlink" title="2.3.1.2 如何加入队列"></a>2.3.1.2 如何加入队列</h4><p>获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br><span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>Node pred = tail;<br><span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>node.prev = pred;<br><span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>pred.next = node;<br><span class="hljs-keyword">return</span> node;<br>&#125;<br>&#125;<br>enq(node);<br><span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetTail</span><span class="hljs-params">(Node expect, Node update)</span> </span>&#123;<br><span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(<span class="hljs-keyword">this</span>, tailOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要的流程如下：</p><ul><li><p>通过当前的线程和锁模式新建一个节点。</p></li><li><p>Pred指针指向尾节点Tail。</p></li><li><p>将New中Node的Prev指针指向Pred。</p></li><li><p>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;state&quot;</span>));<br>headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;head&quot;</span>));<br>tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;tail&quot;</span>));<br>waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="hljs-string">&quot;waitStatus&quot;</span>));<br>nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="hljs-string">&quot;next&quot;</span>));<br>&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。</p></li><li><p>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br>Node t = tail;<br><span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br><span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))<br>tail = head;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>node.prev = t;<br><span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>t.next = node;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p><p>总结一下，线程获取锁的时候，过程大体如下：</p><ol><li>当没有线程获取到锁时，线程1获取锁成功。</li><li>线程2申请锁，但是锁被线程1占有。<img src="/2020/10/08/AQS/image-1602227617.png" class="" title="some description"></li><li>如果再有线程要获取锁，依次在队列中往后排队即可。<br>回到上边的代码，hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.ReentrantLock</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// The correctness of this depends on head being initialized</span><br><span class="hljs-comment">// before tail and on head.next being accurate if the current</span><br><span class="hljs-comment">// thread is first in queue.</span><br>Node t = tail; <span class="hljs-comment">// Read fields in reverse initialization order</span><br>Node h = head;<br>Node s;<br><span class="hljs-keyword">return</span> h != t &amp;&amp; ((s = h.next) == <span class="hljs-keyword">null</span> || s.thread != Thread.currentThread());<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里，我们理解一下h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p><p><em>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当h != t时： 如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</span><br><br><span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br><span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))<br>tail = head;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>node.prev = t;<br><span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>t.next = node;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>节点入队不是原子操作，所以会出现短暂的head != tail，此时Tail指向最后一个节点，而且Tail指向Head。如果Head没有指向Tail（可见5、6、7行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p><h4 id="2-3-1-3-等待队列中线程出队列时机"><a href="#2-3-1-3-等待队列中线程出队列时机" class="headerlink" title="2.3.1.3 等待队列中线程出队列时机"></a>2.3.1.3 等待队列中线程出队列时机</h4><p>回到最初的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。</p><p>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p><p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-comment">// 标记是否成功拿到资源</span><br><span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 标记等待过程中是否中断过</span><br><span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 开始自旋，要么获取锁，要么中断</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">// 获取当前节点的前驱节点</span><br><span class="hljs-keyword">final</span> Node p = node.predecessor();<br><span class="hljs-comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span><br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br><span class="hljs-comment">// 获取锁成功，头指针移动到当前node</span><br>setHead(node);<br>p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>failed = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">return</span> interrupted;<br>&#125;<br><span class="hljs-comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span><br><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>interrupted = <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br>cancelAcquire(node);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHead</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>head = node;<br>node.thread = <span class="hljs-keyword">null</span>;<br>node.prev = <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-comment">// 靠前驱节点判断当前线程是否应该被阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br><span class="hljs-comment">// 获取头结点的节点状态</span><br><span class="hljs-keyword">int</span> ws = pred.waitStatus;<br><span class="hljs-comment">// 说明头结点处于唤醒状态</span><br><span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <br><span class="hljs-comment">// 通过枚举值我们知道waitStatus&gt;0是取消状态</span><br><span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// 循环向前查找取消节点，把取消节点从队列中剔除</span><br>node.prev = pred = pred.prev;<br>&#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>pred.next = node;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 设置前任节点等待状态为SIGNAL</span><br>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    LockSupport.park(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><p>上述方法的流程图如下：</p><img src="/2020/10/08/AQS/image-1602227845.png" class="" title="some description"><p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：</p><img src="/2020/10/08/AQS/image-1602227858.png" class="" title="some description"><p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p><ul><li><p>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</p></li><li><p>是在什么时间释放节点通知到被挂起的线程呢？</p></li></ul><h3 id="2-3-2-CANCELLED状态节点生成"><a href="#2-3-2-CANCELLED状态节点生成" class="headerlink" title="2.3.2 CANCELLED状态节点生成"></a>2.3.2 CANCELLED状态节点生成</h3><p>acquireQueued方法中的Finally代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    ...<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">final</span> Node p = node.predecessor();<br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>...<br>failed = <span class="hljs-keyword">false</span>;<br>        ...<br>&#125;<br>...<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br>cancelAcquire(node);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancelAcquire</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>  <span class="hljs-comment">// 将无效节点过滤</span><br><span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 设置该节点不关联任何线程，也就是虚节点</span><br>node.thread = <span class="hljs-keyword">null</span>;<br>Node pred = node.prev;<br>  <span class="hljs-comment">// 通过前驱节点，跳过取消状态的node</span><br><span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)<br>node.prev = pred = pred.prev;<br>  <span class="hljs-comment">// 获取过滤后的前驱节点的后继节点</span><br>Node predNext = pred.next;<br>  <span class="hljs-comment">// 把当前node的状态设置为CANCELLED</span><br>node.waitStatus = Node.CANCELLED;<br>  <span class="hljs-comment">// 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span><br>  <span class="hljs-comment">// 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span><br><span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br>compareAndSetNext(pred, predNext, <span class="hljs-keyword">null</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">int</span> ws;<br>    <span class="hljs-comment">// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span><br>    <span class="hljs-comment">// 如果1和2中有一个为true，再判断当前节点的线程是否为null</span><br>    <span class="hljs-comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span><br><span class="hljs-keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="hljs-keyword">null</span>) &#123;<br>Node next = node.next;<br><span class="hljs-keyword">if</span> (next != <span class="hljs-keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br>compareAndSetNext(pred, predNext, next);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span><br>unparkSuccessor(node);<br>&#125;<br>node.next = node; <span class="hljs-comment">// help GC</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当前的流程：</p><ul><li><p>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</p></li><li><p>根据当前节点的位置，考虑以下三种情况：</p></li></ul><p>(1) 当前节点是尾节点。</p><p>(2) 当前节点是Head的后继节点。</p><p>(3) 当前节点不是Head的后继节点，也不是尾节点。</p><p>根据上述第二条，我们来分析每一种情况的流程。</p><p>当前节点是尾节点。</p><img src="/2020/10/08/AQS/image-1602227928.png" class="" title="some description"><p>当前节点是Head的后继节点。</p><img src="/2020/10/08/AQS/image-1602227939.png" class="" title="some description"><p>当前节点不是Head的后继节点，也不是尾节点。</p><img src="/2020/10/08/AQS/image-1602227951.png" class="" title="some description"><p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p><p><em>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br>node.prev = pred = pred.prev;<br>&#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="2-3-3-如何解锁"><a href="#2-3-3-如何解锁" class="headerlink" title="2.3.3 如何解锁"></a>2.3.3 如何解锁</h3><p>我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.ReentrantLock</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>sync.release(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，本质释放锁的地方，是通过框架来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>Node h = head;<br><span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>unparkSuccessor(h);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.ReentrantLock.Sync</span><br><br><span class="hljs-comment">// 方法返回当前锁是不是没有被线程持有</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br><span class="hljs-comment">// 减少可重入次数</span><br><span class="hljs-keyword">int</span> c = getState() - releases;<br><span class="hljs-comment">// 当前线程不是持有锁的线程，抛出异常</span><br><span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br><span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>free = <span class="hljs-keyword">true</span>;<br>setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>&#125;<br>setState(c);<br><span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来解释下述源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-comment">// 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br><span class="hljs-comment">// 获取头结点</span><br>Node h = head;<br><span class="hljs-comment">// 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态</span><br><span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>unparkSuccessor(h);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？</p><p><em>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。 h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。 h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</em></p><p>再看一下unparkSuccessor方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br><span class="hljs-comment">// 获取头结点waitStatus</span><br><span class="hljs-keyword">int</span> ws = node.waitStatus;<br><span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 获取当前节点的下一个节点</span><br>Node s = node.next;<br><span class="hljs-comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span><br><span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>s = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span><br><span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<br><span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>s = t;<br>&#125;<br><span class="hljs-comment">// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把当前节点unpark</span><br><span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。</p><p>之前的addWaiter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br><span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>Node pred = tail;<br><span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>node.prev = pred;<br><span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>pred.next = node;<br><span class="hljs-keyword">return</span> node;<br>&#125;<br>&#125;<br>enq(node);<br><span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？</p><h3 id="2-3-4-中断恢复后的执行流程"><a href="#2-3-4-中断恢复后的执行流程" class="headerlink" title="2.3.4 中断恢复后的执行流程"></a>2.3.4 中断恢复后的执行流程</h3><p>唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>LockSupport.park(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure><p>再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br><span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-keyword">final</span> Node p = node.predecessor();<br><span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>setHead(node);<br>p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>failed = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">return</span> interrupted;<br>&#125;<br><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())<br>interrupted = <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failed)<br>cancelAcquire(node);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果acquireQueued为True，就会执行selfInterrupt方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selfInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：</p><ol><li><p>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</p></li><li><p>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</p></li></ol><p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下ThreadPoolExecutor源码。</p><h3 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h3><h5 id="Q：某个线程获取锁失败的后续流程是什么呢？"><a href="#Q：某个线程获取锁失败的后续流程是什么呢？" class="headerlink" title="Q：某个线程获取锁失败的后续流程是什么呢？"></a>Q：某个线程获取锁失败的后续流程是什么呢？</h5><p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><h5 id="Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？"><a href="#Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？" class="headerlink" title="Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？"></a>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</h5><p>A：是CLH变体的FIFO双端队列。</p><h5 id="Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？"><a href="#Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？" class="headerlink" title="Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？"></a>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</h5><p>A：可以详细看下2.3.1.3小节。</p><h5 id="Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？"><a href="#Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？" class="headerlink" title="Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？"></a>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</h5><p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p><h5 id="Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？"><a href="#Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？" class="headerlink" title="Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？"></a>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</h5><p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p><h1 id="3-AQS应用"><a href="#3-AQS应用" class="headerlink" title="3 AQS应用"></a>3 AQS应用</h1><h2 id="3-1-ReentrantLock的可重入应用"><a href="#3-1-ReentrantLock的可重入应用" class="headerlink" title="3.1 ReentrantLock的可重入应用"></a>3.1 ReentrantLock的可重入应用</h2><p>ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。</p><p>公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span><br><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br><span class="hljs-keyword">int</span> nextc = c + acquires;<br><span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(nextc);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>非公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span><br><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires))&#123;<br>setExclusiveOwnerThread(current);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br><span class="hljs-keyword">int</span> nextc = c + acquires;<br><span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>setState(nextc);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。State是Volatile修饰的，用于保证一定的可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br></code></pre></td></tr></table></figure><p>接下来看State这个字段主要的过程：</p><ol><li><p>State初始化的时候为0，表示没有任何线程持有锁。</p></li><li><p>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</p></li><li><p>解锁也是对这个字段-1，一直到0，此线程对锁释放。</p></li></ol><h2 id="3-2-JUC中的应用场景"><a href="#3-2-JUC中的应用场景" class="headerlink" title="3.2 JUC中的应用场景"></a>3.2 JUC中的应用场景</h2><p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p><img src="/2020/10/08/AQS/image-1602228428.png" class="" title="some description"><h3 id="3-3-自定义同步工具"><a href="#3-3-自定义同步工具" class="headerlink" title="3.3 自定义同步工具"></a>3.3 自定义同步工具</h3><p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeeLock</span>  </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span> <span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Sync sync = <span class="hljs-keyword">new</span> Sync();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span> <span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span> <span class="hljs-params">()</span> </span>&#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过我们自己定义的Lock完成一定的同步功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeeMain</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> LeeLock leeLock = <span class="hljs-keyword">new</span> LeeLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br><br>        Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span> <span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    leeLock.lock();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>                        count++;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    leeLock.unlock();<br>                &#125;<br><br>            &#125;<br>        &#125;;<br>        Thread thread1 = <span class="hljs-keyword">new</span> Thread(runnable);<br>        Thread thread2 = <span class="hljs-keyword">new</span> Thread(runnable);<br>        thread1.start();<br>        thread2.start();<br>        thread1.join();<br>        thread2.join();<br>        System.out.println(count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p><p><em>本文章转载自： <a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></em></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vagrant创建管理虚拟机</title>
    <link href="/2019/07/13/yq/hn553n/"/>
    <url>/2019/07/13/yq/hn553n/</url>
    
    <content type="html"><![CDATA[<h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><ul><li>Install the latest version of <a href="https://www.vagrantup.com/docs/installation/">Vagrant</a>.</li><li>Install <a href="https://www.virtualbox.org/">VirtualBox</a></li></ul><h2 id="vargrant-使用"><a href="#vargrant-使用" class="headerlink" title="vargrant 使用"></a>vargrant 使用</h2><p>在任意目录下创建 vagrantfile 文件</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ruby">Vagrant.configure(<span class="hljs-string">&quot;2&quot;</span>) <span class="hljs-keyword">do</span> <span class="hljs-params">|config|</span><br>   (<span class="hljs-number">1</span>..<span class="hljs-number">3</span>).each <span class="hljs-keyword">do</span> <span class="hljs-params">|i|</span><br>        config.vm.define <span class="hljs-string">&quot;k8s-node<span class="hljs-subst">#&#123;i&#125;</span>&quot;</span> <span class="hljs-keyword">do</span> <span class="hljs-params">|node|</span><br>            <span class="hljs-comment"># 设置虚拟机的Box</span><br>            node.vm.box = <span class="hljs-string">&quot;centos/7&quot;</span><br><br>            <span class="hljs-comment"># 设置虚拟机的主机名</span><br>            node.vm.hostname=<span class="hljs-string">&quot;k8s-node<span class="hljs-subst">#&#123;i&#125;</span>&quot;</span><br><br>            <span class="hljs-comment"># 设置虚拟机的IP</span><br>            node.vm.network <span class="hljs-string">&quot;private_network&quot;</span>, <span class="hljs-symbol">ip:</span> <span class="hljs-string">&quot;192.168.56.<span class="hljs-subst">#&#123;<span class="hljs-number">99</span>+i&#125;</span>&quot;</span>, <span class="hljs-symbol">netmask:</span> <span class="hljs-string">&quot;255.255.255.0&quot;</span><br><br>            <span class="hljs-comment"># 设置主机与虚拟机的共享目录</span><br>            <span class="hljs-comment"># node.vm.synced_folder &quot;~/Documents/vagrant/share&quot;, &quot;/home/vagrant/share&quot;</span><br><br>            <span class="hljs-comment"># VirtaulBox相关配置</span><br>            node.vm.provider <span class="hljs-string">&quot;virtualbox&quot;</span> <span class="hljs-keyword">do</span> <span class="hljs-params">|v|</span><br>                <span class="hljs-comment"># 设置虚拟机的名称</span><br>                v.name = <span class="hljs-string">&quot;k8s-node<span class="hljs-subst">#&#123;i&#125;</span>&quot;</span><br>                <span class="hljs-comment"># 设置虚拟机的内存大小</span><br>                v.memory = <span class="hljs-number">4096</span><br>                <span class="hljs-comment"># 设置虚拟机的CPU个数</span><br>                v.cpus = <span class="hljs-number">4</span><br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>在文件所在的目录下，执行<code>vagrant up</code> 创建并启动虚拟机， 执行<code>vagrant ssh</code> 连接进入到虚拟机控制台。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vagrant</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>junit5 annotation</title>
    <link href="/2019/04/10/yq/ivmag1/"/>
    <url>/2019/04/10/yq/ivmag1/</url>
    
    <content type="html"><![CDATA[<p>junit5 annotation 详细</p><table><thead><tr><th align="left">Annotation</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code>@Test</code></td><td align="left">Denotes that a method is a test method. Unlike JUnit 4’s <code>@Test</code> annotation, this annotation does not declare any attributes, since test extensions in JUnit Jupiter operate based on their own dedicated annotations. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr><tr><td align="left"><code>@ParameterizedTest</code></td><td align="left">Denotes that a method is a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests">parameterized test</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr><tr><td align="left"><code>@RepeatedTest</code></td><td align="left">Denotes that a method is a test template for a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-repeated-tests">repeated test</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr><tr><td align="left"><code>@TestFactory</code></td><td align="left">Denotes that a method is a test factory for <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests">dynamic tests</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr><tr><td align="left"><code>@TestTemplate</code></td><td align="left">Denotes that a method is a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-templates">template for test cases</a> designed to be invoked multiple times depending on the number of invocation contexts returned by the registered <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-test-templates">providers</a>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr><tr><td align="left"><code>@TestMethodOrder</code></td><td align="left">Used to configure the <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-execution-order">test method execution order</a> for the annotated test class; similar to JUnit 4’s <code>@FixMethodOrder</code>. Such annotations are <em>inherited</em>.</td></tr><tr><td align="left"><code>@TestInstance</code></td><td align="left">Used to configure the <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> for the annotated test class. Such annotations are <em>inherited</em>.</td></tr><tr><td align="left"><code>@DisplayName</code></td><td align="left">Declares a custom <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-names">display name</a> for the test class or test method. Such annotations are not <em>inherited</em>.</td></tr><tr><td align="left"><code>@DisplayNameGeneration</code></td><td align="left">Declares a custom <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-display-name-generator">display name generator</a> for the test class. Such annotations are <em>inherited</em>.</td></tr><tr><td align="left"><code>@BeforeEach</code></td><td align="left">Denotes that the annotated method should be executed <em>before</em> <strong>each</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, or <code>@TestFactory</code> method in the current class; analogous to JUnit 4’s <code>@Before</code>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr><tr><td align="left"><code>@AfterEach</code></td><td align="left">Denotes that the annotated method should be executed <em>after</em> <strong>each</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, or <code>@TestFactory</code> method in the current class; analogous to JUnit 4’s <code>@After</code>. Such methods are <em>inherited</em> unless they are <em>overridden</em>.</td></tr><tr><td align="left"><code>@BeforeAll</code></td><td align="left">Denotes that the annotated method should be executed <em>before</em> <strong>all</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, and <code>@TestFactory</code> methods in the current class; analogous to JUnit 4’s <code>@BeforeClass</code>. Such methods are <em>inherited</em> (unless they are <em>hidden</em> or <em>overridden</em>) and must be <code>static</code> (unless the “per-class” <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used).</td></tr><tr><td align="left"><code>@AfterAll</code></td><td align="left">Denotes that the annotated method should be executed <em>after</em> <strong>all</strong> <code>@Test</code>, <code>@RepeatedTest</code>, <code>@ParameterizedTest</code>, and <code>@TestFactory</code> methods in the current class; analogous to JUnit 4’s <code>@AfterClass</code>. Such methods are <em>inherited</em> (unless they are <em>hidden</em> or <em>overridden</em>) and must be <code>static</code> (unless the “per-class” <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used).</td></tr><tr><td align="left"><code>@Nested</code></td><td align="left">Denotes that the annotated class is a non-static <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested">nested test class</a>. <code>@BeforeAll</code> and <code>@AfterAll</code> methods cannot be used directly in a <code>@Nested</code> test class unless the “per-class” <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle">test instance lifecycle</a> is used. Such annotations are not <em>inherited</em>.</td></tr><tr><td align="left"><code>@Tag</code></td><td align="left">Used to declare <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-tagging-and-filtering">tags for filtering tests</a>, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are <em>inherited</em> at the class level but not at the method level.</td></tr><tr><td align="left"><code>@Disabled</code></td><td align="left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-disabling">disable</a> a test class or test method; analogous to JUnit 4’s <code>@Ignore</code>. Such annotations are not <em>inherited</em>.</td></tr><tr><td align="left"><code>@Timeout</code></td><td align="left">Used to fail a test, test factory, test template, or lifecycle method if its execution exceeds a given duration. Such annotations are <em>inherited</em>.</td></tr><tr><td align="left"><code>@ExtendWith</code></td><td align="left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration-declarative">register extensions declaratively</a>. Such annotations are <em>inherited</em>.</td></tr><tr><td align="left"><code>@RegisterExtension</code></td><td align="left">Used to <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration-programmatic">register extensions programmatically</a> via fields. Such fields are <em>inherited</em> unless they are <em>shadowed</em>.</td></tr><tr><td align="left"><code>@TempDir</code></td><td align="left">Used to supply a <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-built-in-extensions-TempDirectory">temporary directory</a> via field injection or parameter injection in a lifecycle method or test method; located in the <code>org.junit.jupiter.api.io</code> package.</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>junit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>update by partition</title>
    <link href="/2019/03/01/update-by-partition/"/>
    <url>/2019/03/01/update-by-partition/</url>
    
    <content type="html"><![CDATA[<p>sql update top 5</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>  <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> col1, col2<br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> x <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">AS</span> r,<br>  t.id<br>  <span class="hljs-keyword">FROM</span><br>    some_table t<br>  <span class="hljs-keyword">where</span> <span class="hljs-keyword">condition</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br>) A<br><span class="hljs-keyword">where</span> A.r <span class="hljs-operator">&lt;</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>postgresql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker中exec和attach区别</title>
    <link href="/2018/08/08/Docker%E4%B8%ADexec%E5%92%8Cattach%E5%8C%BA%E5%88%AB/"/>
    <url>/2018/08/08/Docker%E4%B8%ADexec%E5%92%8Cattach%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>docker attach 执行后会进入到 container 中<br>docker exec 执行后，命令执行返回值并显示到宿主机中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker alias</title>
    <link href="/2018/02/11/docker-alias/"/>
    <url>/2018/02/11/docker-alias/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="Docker-alias-and-function"><a href="#Docker-alias-and-function" class="headerlink" title="Docker alias and function"></a>Docker alias and function</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs sh">Get latest container ID<br><span class="hljs-built_in">alias</span> dl=<span class="hljs-string">&quot;docker ps -l -q&quot;</span><br><br>Get container process<br><span class="hljs-built_in">alias</span> dps=<span class="hljs-string">&quot;docker ps&quot;</span><br><br>Get process included stop container<br><span class="hljs-built_in">alias</span> dpa=<span class="hljs-string">&quot;docker ps -a&quot;</span><br><br>Get images<br><span class="hljs-built_in">alias</span> di=<span class="hljs-string">&quot;docker images&quot;</span><br><br>Get container IP<br><span class="hljs-built_in">alias</span> dip=<span class="hljs-string">&quot;docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;&quot;</span><br><br>Run deamonized container, e.g., <span class="hljs-variable">$dkd</span> base /bin/<span class="hljs-built_in">echo</span> hello<br><span class="hljs-built_in">alias</span> dkd=<span class="hljs-string">&quot;docker run -d -P&quot;</span><br><br>Run interactive container, e.g., <span class="hljs-variable">$dki</span> base /bin/bash<br><span class="hljs-built_in">alias</span> dki=<span class="hljs-string">&quot;docker run -i -t -P&quot;</span><br><br>Execute interactive container, e.g., <span class="hljs-variable">$dex</span> base /bin/bash<br><span class="hljs-built_in">alias</span> dex=<span class="hljs-string">&quot;docker exec -i -t&quot;</span><br><br>Stop all containers<br><span class="hljs-function"><span class="hljs-title">dstop</span></span>() &#123; docker stop $(docker ps -a -q); &#125;<br><br>Remove all containers<br><span class="hljs-function"><span class="hljs-title">drm</span></span>() &#123; docker rm $(docker ps -a -q); &#125;<br><br>Stop and Remove all containers<br><span class="hljs-built_in">alias</span> drmf=<span class="hljs-string">&#x27;docker stop $(docker ps -a -q) &amp;&amp; docker rm $(docker ps -a -q)&#x27;</span><br><br>Remove all images<br><span class="hljs-function"><span class="hljs-title">dri</span></span>() &#123; docker rmi $(docker images -q); &#125;<br><br>Dockerfile build, e.g., <span class="hljs-variable">$dbu</span> tcnksm/<span class="hljs-built_in">test</span><br><span class="hljs-function"><span class="hljs-title">dbu</span></span>() &#123; docker build -t=<span class="hljs-variable">$1</span> .; &#125;<br><br>Show all <span class="hljs-built_in">alias</span> related docker<br><span class="hljs-function"><span class="hljs-title">dalias</span></span>() &#123; <span class="hljs-built_in">alias</span> | grep <span class="hljs-string">&#x27;docker&#x27;</span> | sed <span class="hljs-string">&quot;s/^([^=])=(.)/\1 =&gt; \2/&quot;</span>| sed <span class="hljs-string">&quot;s/[&#x27;|&#x27;]//g&quot;</span> | sort; &#125;<br><br>Bash into running container<br><span class="hljs-function"><span class="hljs-title">dbash</span></span>() &#123; docker <span class="hljs-built_in">exec</span> -it $(docker ps -aqf <span class="hljs-string">&quot;name=<span class="hljs-variable">$1</span>&quot;</span>) bash; &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker常用命令及使用</title>
    <link href="/2017/11/20/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/2017/11/20/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>以下是在 centos 系统下执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br><br>sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo<br><br>sudo yum makecache fast<br><br>sudo yum install docker-ce<br><br>vi /etc/docker/daemon.json<br><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span> : [<br>    <span class="hljs-string">&quot;https://xxxx.mirror.aliyuncs.com&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;insecure-registries&quot;</span> : [<br>    <span class="hljs-string">&quot;registry.mirrors.aliyuncs.com&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;debug&quot;</span> : <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;experimental&quot;</span> : <span class="hljs-literal">true</span><br>&#125;<br>sudo systemctl start docker<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
