{"meta":{"title":"TJ's Blog","subtitle":null,"description":"backend;java;typescript;graphql;fullstack","author":"TJ","url":"https://voox.cc"},"pages":[{"title":"categories","date":"2019-01-31T02:54:24.000Z","updated":"2019-01-31T02:54:24.806Z","comments":true,"path":"categories/index.html","permalink":"https://voox.cc/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-03-19T06:59:53.000Z","updated":"2020-10-08T15:12:43.067Z","comments":false,"path":"about/index.html","permalink":"https://voox.cc/about/index.html","excerpt":"","text":"var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?c1b31db7a7ea55c71d92dc4a7cea0cc3\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); About Me个人信息 TJ / 男背景 \b 及其技能 2011 年至今 Java 企业级开发经验 熟悉基于 Spring-cloud 微服务架构 熟悉 Nodejs, Docker, RabbitMQ, Redis, Postgres, Typescript, GraphQL 熟悉 Github, Bitbucket 参与过开源项目和开源社区的建设和开发 联系方式微信 Email (base64) aUB2b294LmNj Github https://github.com/aooppo"},{"title":"about","date":"2020-03-19T06:59:53.000Z","updated":"2020-10-08T14:49:57.033Z","comments":false,"path":"projects/index.html","permalink":"https://voox.cc/projects/index.html","excerpt":"","text":""}],"posts":[{"title":"从0到1手写一个RPC实现","slug":"从0到1手写一个RPC实现","date":"2020-10-08T05:35:36.000Z","updated":"2020-10-08T05:45:44.720Z","comments":true,"path":"2020/10/08/从0到1手写一个RPC实现/","link":"","permalink":"https://voox.cc/2020/10/08/从0到1手写一个RPC实现/","excerpt":"","text":"计划从0到1手写一个RPC的实现我准备把具体实现和想法记录下来，对学习其他RPC框架有一个参考和比较。可能用到的技术栈： spring netty kryo, protobuf, thrift, hessian (序列化和反序列化) zookeeper, etcd, redis (服务注册和发现)","categories":[],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://voox.cc/tags/rpc/"},{"name":"java","slug":"java","permalink":"https://voox.cc/tags/java/"}]},{"title":"AQS","slug":"AQS","date":"2020-10-08T04:48:48.000Z","updated":"2020-10-08T05:28:46.727Z","comments":true,"path":"2020/10/08/AQS/","link":"","permalink":"https://voox.cc/2020/10/08/AQS/","excerpt":"","text":"1 ReentrantLock1.1 ReentrantLock特性概览ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下: // **************************Synchronized的使用方式**************************// 1.用于代码块synchronized (this) &#123;&#125;// 2.用于对象synchronized (object) &#123;&#125;// 3.用于方法public synchronized void test () &#123;&#125;// 4.可重入for (int i = 0; i &lt; 100; i++) &#123; synchronized (this) &#123;&#125;&#125;// **************************ReentrantLock的使用方式**************************public void test () throw Exception &#123; // 1.初始化选择公平锁、非公平锁 ReentrantLock lock = new ReentrantLock(true); // 2.可用于代码块 lock.lock(); try &#123; try &#123; // 3.支持多种加锁方式，比较灵活; 具有可重入特性 if(lock.tryLock(100, TimeUnit.MILLISECONDS))&#123; &#125; &#125; finally &#123; // 4.手动释放锁 lock.unlock() &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 1.2 ReentrantLock与AQS的关联非公平锁源码中的加锁流程如下： // java.util.concurrent.locks.ReentrantLock#NonfairSync// 非公平锁static final class NonfairSync extends Sync &#123; ... final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; ...&#125; 这块代码的含义为： 若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。 若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。 第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考： 某个线程获取锁失败的后续流程是什么呢？有以下两种可能：(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。 (2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。 对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？ 处于排队等候机制中的线程，什么时候可以有机会获取锁呢？ 如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？ 带着非公平锁的这些问题，再看下公平锁源码中获锁的方式： // java.util.concurrent.locks.ReentrantLock#FairSyncstatic final class FairSync extends Sync &#123; ... final void lock() &#123; acquire(1); &#125; ...&#125; 看到这块代码，我们可能会存在这种疑问：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？ 结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。 对于上边提到的问题，其实在ReentrantLock类源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。","categories":[],"tags":[]},{"title":"update by partition","slug":"update-by-partition","date":"2019-03-01T07:25:19.000Z","updated":"2019-03-01T07:29:11.238Z","comments":true,"path":"2019/03/01/update-by-partition/","link":"","permalink":"https://voox.cc/2019/03/01/update-by-partition/","excerpt":"","text":"sql update top 5 SELECT ROW_NUMBER() OVER (PARTITION BY col1, col2 ORDER BY x desc) AS r, t.id FROM some_table t where condition = 'xxx') Awhere A.r &lt; 5;","categories":[],"tags":[{"name":"sql","slug":"sql","permalink":"https://voox.cc/tags/sql/"},{"name":"postgresql","slug":"postgresql","permalink":"https://voox.cc/tags/postgresql/"}]},{"title":"redux saga presentation","slug":"redux-saga-to","date":"2019-02-03T15:49:43.000Z","updated":"2019-02-03T15:55:41.074Z","comments":true,"path":"2019/02/03/redux-saga-to/","link":"","permalink":"https://voox.cc/2019/02/03/redux-saga-to/","excerpt":"","text":"https://youtu.be/o3A9EvMspig","categories":[],"tags":[{"name":"redux","slug":"redux","permalink":"https://voox.cc/tags/redux/"}]},{"title":"Docker中exec和attach区别","slug":"Docker中exec和attach区别","date":"2018-08-08T02:57:20.000Z","updated":"2019-01-31T06:11:40.735Z","comments":true,"path":"2018/08/08/Docker中exec和attach区别/","link":"","permalink":"https://voox.cc/2018/08/08/Docker中exec和attach区别/","excerpt":"","text":"docker attach 执行后会进入到 container 中docker exec 执行后，命令执行返回值并显示到宿主机中。","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://voox.cc/tags/docker/"}]},{"title":"Docker alias","slug":"docker-alias","date":"2018-02-11T06:07:03.000Z","updated":"2019-01-31T06:14:34.507Z","comments":true,"path":"2018/02/11/docker-alias/","link":"","permalink":"https://voox.cc/2018/02/11/docker-alias/","excerpt":"","text":"Docker alias and functionGet latest container IDalias dl=\"docker ps -l -q\"Get container processalias dps=\"docker ps\"Get process included stop containeralias dpa=\"docker ps -a\"Get imagesalias di=\"docker images\"Get container IPalias dip=\"docker inspect --format '&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;'\"Run deamonized container, e.g., $dkd base /bin/echo helloalias dkd=\"docker run -d -P\"Run interactive container, e.g., $dki base /bin/bashalias dki=\"docker run -i -t -P\"Execute interactive container, e.g., $dex base /bin/bashalias dex=\"docker exec -i -t\"Stop all containersdstop() &#123; docker stop $(docker ps -a -q); &#125;Remove all containersdrm() &#123; docker rm $(docker ps -a -q); &#125;Stop and Remove all containersalias drmf='docker stop $(docker ps -a -q) &amp;&amp; docker rm $(docker ps -a -q)'Remove all imagesdri() &#123; docker rmi $(docker images -q); &#125;Dockerfile build, e.g., $dbu tcnksm/testdbu() &#123; docker build -t=$1 .; &#125;Show all alias related dockerdalias() &#123; alias | grep 'docker' | sed \"s/^([^=])=(.)/\\1 =&gt; \\2/\"| sed \"s/['|']//g\" | sort; &#125;Bash into running containerdbash() &#123; docker exec -it $(docker ps -aqf \"name=$1\") bash; &#125;","categories":[],"tags":[{"name":"shell","slug":"shell","permalink":"https://voox.cc/tags/shell/"}]},{"title":"Docker常用命令及使用","slug":"Docker常用命令及使用","date":"2017-11-20T05:45:18.000Z","updated":"2019-02-01T02:48:19.522Z","comments":true,"path":"2017/11/20/Docker常用命令及使用/","link":"","permalink":"https://voox.cc/2017/11/20/Docker常用命令及使用/","excerpt":"","text":"以下是在 centos 系统下执行 sudo yum install -y yum-utils device-mapper-persistent-data lvm2sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.reposudo yum makecache fastsudo yum install docker-cevi /etc/docker/daemon.json&#123; \"registry-mirrors\" : [ \"https://xxxx.mirror.aliyuncs.com\" ], \"insecure-registries\" : [ \"registry.mirrors.aliyuncs.com\" ], \"debug\" : true, \"experimental\" : true&#125;sudo systemctl start docker","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://voox.cc/tags/docker/"},{"name":"shell","slug":"shell","permalink":"https://voox.cc/tags/shell/"}]}]}